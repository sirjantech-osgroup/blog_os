+++
title = "Async/Await"
weight = 12
path = "fa/async-await"
date = 2020-03-27

[extra]
chapter = "Multitasking"
# Please update this when updating the translation
translation_based_on_commit = "aa389dae4b0b756a13ae3c330fa9bdf55d5f5ba"
# GitHub usernames of the people that translated this post
translators = ["hamidrezakp", "MHBahrampour"]
rtl = true
+++

در این پست به بررسی _چند وظیفه‌ای تعاونی_ (ترجمه: ooperative multitasking) و ویژگی _async/await_ راست می‌پردازیم. نگاهی دقیق به نحوه عملکرد async/await در راست می‌اندازیم، از جمله طراحی صفت `Future`، تبدیل ماشین حالت، و _سنجاق کردن_ (ترجمه: pinning). سپس با ایجاد یک وظیفه صفحه کلید ناهمزمان (asynchronous) و یک اجرا کننده اصلی، پشتیبانی اولیه برای async/await را به هسته اضافه می‌کنیم.

<!-- more -->

این بلاگ بصورت آزاد روی [گیت‌هاب] توسعه داده شده است. اگر شما مشکل یا سوالی دارید، لطفاً آن‌جا یک ایشو باز کنید. شما همچنین می‌توانید [در زیر] این پست کامنت بگذارید. منبع کد کامل این پست را می‌توانید در بِرَنچ [`post-12`][post branch] پیدا کنید.

[گیت‌هاب]: https://github.com/phil-opp/blog_os
[در زیر]: #comments
<!-- fix for zola anchor checker (target is in template): <a id="comments"> -->
[post branch]: https://github.com/phil-opp/blog_os/tree/post-12

<!-- toc -->

## چند وظیفه‌ای

یکی از ویژگی‌های اساسی اکثر سیستم‌عامل‌ها [_چند وظیفه‌ای_] است که توانایی اجرای چندین وظیفه به طور همزمان (synchronous) است. برای مثال، احتمالاً برنامه‌های دیگری مانند ویرایشگر متن یا پنجره ترمینال را هنگام تماشای این پست باز دارید. حتی اگر تنها یک پنجره مرورگر باز دارید، احتمالاً وظایف پس‌زمینه مختلفی برای مدیریت پنجره‌های دسکتاپ، بررسی به‌روزرسانی‌ها یا فهرست کردن فایل‌ها وجود دارد.

[_چند وظیفه‌ای_]: https://en.wikipedia.org/wiki/Computer_multitasking

در حالی که به نظر می‌رسد همه وظایف به صورت موازی اجرا می‌شوند، تنها یک وظیفه را می‌توان در هر لحظه بر روی یک هسته CPU اجرا کرد. برای ایجاد این توهم که وظایف به صورت موازی اجرا می‌شوند، سیستم‌عامل به سرعت بین وظایف فعال جابه‌جا می‌شود تا هر کدام بتوانند اندکی پیشرفت کنند. از آ‌ن‌جایی که رایانه‌ها سریع هستند، ما اغلب متوجه این جابه‌جایی‌ها نمی‌شویم.

در حالی که CPUهای تک هسته‌ای می‌توانند تنها یک وظیفه را در یک لحظه اجرا کنند، CPUهای چند هسته‌ای می‌توانند چندین وظیفه را به صورت موازی انجام دهند. به عنوان مثال، یک CPU با 8 هسته می‌تواند 8 وظیفه را همزمان انجام دهد. نحوه راه‌اندازی CPUهای چند هسته‌ای را در پست بعدی توضیح خواهیم داد. برای این پست، ما برای سادگی بر روی CPU‌های تک هسته‌ای تمرکز خواهیم کرد. (شایان ذکر است که تمام پردازنده‌های چند هسته‌ای تنها با یک هسته فعال شروع می‌شوند، بنابراین می‌توانیم فعلاً آن‌ها را به عنوان پردازنده‌های تک هسته‌ای در نظر بگیریم.)

دو شکل چندوظیفه‌ای وجود دارد: چندوظیفه‌ای _cooperative_ (ترجمه: تعاونی) نیازمند وظایفی است که به طور منظم کنترل CPU را کنار بگذارند تا سایر وظایف بتوانند پیشرفت کنند. چندوظیفه‌ای _preemptive_ (ترجمه: پیشگیرانه) از عملکرد سیستم‌عامل برای تعویض نخ‌ها در نقاط دلخواه در زمان با توقف اجباری آن‌ها استفاده می‌کند. در ادامه ما دو شکل چندوظیفه‌ای را با جزئیات بیشتری بررسی خواهیم کرد و مزایا و معایب مربوط به آن‌ها را مورد بحث قرار خواهیم داد.

### چند وظیفه‌ای پیشگیرانه

ایده پشت چند وظیفه‌ای پیشگیرانه این است که سیستم‌عامل زمان تعویض وظایف را کنترل می‌کند. برای آن، از این واقعیت استفاده می‌کند که کنترل CPU را در هر وقفه به دست می‌آورد. این امر امکان تعویض وظایف را هر زمان که ورودی جدیدی در سیستم وجود دارد، ممکن می‌سازد. به عنوان مثال، زمانی که ماوس حرکت می‌کند یا یک بسته شبکه می‌رسد، می‌توان وظایف را تعویض کرد. سیستم‌عامل همچنین می‌تواند با پیکربندی یک تایمر سخت‌افزاری برای ارسال وقفه پس گذشت مدت زمان مورد نظر، زمان دقیقی را که یک وظیفه مجاز به اجرا است را تعیین کند.

نمودار زیر فرآیند تعویض وظیفه در یک وقفه سخت‌افزاری را نشان می‌دهد:

![](regain-control-on-interrupt.svg)


[_وقفه‌های سخت‌افزاری_]: @/edition-2/posts/07-hardware-interrupts/index.md

#### ذخیره وضعیت

از آن‌جایی که وظیفه‌ها در مقاطع زمانی دلخواه قطع می‌شوند، ممکن است آن وقفه‌ها وسط محاسبات دیگری باشند. برای این‌که CPU بتواند بعداً آن‌ها را از سر بگیرد، سیستم‌عامل باید از کل وضعیت وظیفه، از جمله [call stack] و مقادیر تمام ثبات‌های CPU، پشتیبان تهیه کند. این فرآیند [_تعویض متن_] (ترجمه: context switch) نامیده می‌شود.

[call stack]: https://en.wikipedia.org/wiki/Call_stack
[_تعویض متن_]: https://en.wikipedia.org/wiki/Context_switch

از آن‌جایی که پشته تماس می‌تواند بسیار بزرگ باشد، سیستم‌عامل معمولاً به‌جای پشتیبان‌گیری از محتوای پشته تماس در هر تعویض وظیفه، یک پشته تماس جداگانه برای هر وظیفه تنظیم می‌کند. چنین وظیفه‌ای با پشته جداگانه را [_thread of execution_] یا به اختصار _thread_ نامیده می‌شود. با استفاده از یک پشته جداگانه برای هر وظیفه، فقط محتویات ثبات باید در یک تعویض متن (شامل شمارنده برنامه و نشانگر پشته) ذخیره شود. این رویکرد سربار عملکرد یک تعویض متن را به حداقل می‌رساند، که بسیار مهم است زیرا تعویض‌های متن اغلب تا ۱۰۰ بار در ثانیه رخ می‌دهند.

[_thread of execution_]: https://en.wikipedia.org/wiki/Thread_(computing)

#### گفتگو

مزیت اصلی چندوظیفه ای پیشگیرانه این است که سیستم عامل می تواند زمان اجرای مجاز یک وظیفه را به‌طور کامل کنترل کند. به این ترتیب، می‌تواند تضمین کند که هر وظیفه سهم عادلانه‌ای از زمان CPU را دریافت می‌کند، بدون این‌که نیازی به اعتماد به وظایف برای همکاری باشد. این امر به ویژه هنگام اجرای وظایف شخص ثالث یا زمانی که چندین کاربر یک سیستم را به اشتراک می‌گذارند بسیار مهم است.

نقطه ضعف این روش این است که هر وظیفه به پشته خاص خود نیاز دارد. این روش در مقایسه با یک پشته مشترک، منجر به استفاده بیشتر از حافظه در هر وظیفه می‌شود و اغلب تعداد وظایف را در سیستم محدود می‌کند. نقطه ضعف دیگر این است که سیستم‌عامل همیشه باید وضعیت ثبات CPU را بصورت کامل در هر سوئیچ وظیفه ذخیره کند، حتی اگر وظیفه فقط از یک زیر مجموعه کوچک از ثبات‌ها استفاده کند.

چند وظیفه‌ای پیشگیرانه و نخ‌ها اجزای اساسی یک سیستم‌عامل هستند زیرا اجرای برنامه‌های فضای کاربری نامعتبر را ممکن می‌سازند. در پست‌های فیوچر‌ به‌طور کامل به این مفاهیم خواهیم پرداخت. با این حال، برای این پست، روی چند وظیفه‌ای مشارکتی تمرکز خواهیم کرد، که همچنین قابلیت‌های مفیدی را برای هسته ما فراهم می‌کند.

### چند وظیفه‌ای مشارکتی

به جای توقف اجباری وظایف در حال اجرا در مقاطع زمانی دلخواه، چند وظیفه‌ای مشارکتی به هر وظیفه اجازه می‌دهد تا زمانی که خود وظیفه به‌طور داوطلبانه کنترل CPU را رها کند، اجرا شود. این به وظیفه‌ها اجازه می‌دهد در زمان‌های مناسب وقفه را ایجاد کنند، برای مثال زمانی که به هر حال باید منتظر عملیات I/O باشد.

چند وظیفه‌ای مشارکتی اغلب در سطح زبان استفاده می‌شود، به عنوان مثال به شکل [coroutines] یا [coroutines]. ایده این است که برنامه‌نویس یا کامپایلر عملیات [_yield_] را در برنامه وارد می‌کند، که کنترل CPU را رها می‌کند و به سایر وظایف اجازه می‌دهد تا اجرا شوند. به عنوان مثال، یک بازده (ترجمه: yield) می‌تواند پس از هر بار تکرار یک حلقه پیچیده درج شود.

[coroutines]: https://en.wikipedia.org/wiki/Coroutine
[async/await]: https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html
[_yield_]: https://en.wikipedia.org/wiki/Yield_(multithreading)

ترکیب چند وظیفه‌ای مشترک با [asynchronous operations] (ترجمه: عملیات ناهمزمان) رایج است. به جای این‌که منتظر بمانید تا یک عملیات به پایان برسد و از اجرای سایر وظایف در این زمان جلوگیری شود، اگر عملیات هنوز تمام نشده باشد، عملیات ناهمزمان وضعیت "not ready" را برمی‌گرداند. در این حالت، وظیفه منتظر می‌تواند یک عملیات بازده را اجرا کند تا به سایر وظایف اجازه اجرای بدهد.

[asynchronous operations]: https://en.wikipedia.org/wiki/Asynchronous_I/O

#### ذخیره وضعیت

از آن‌جایی که وظایف، نقاط وقفه خود را مشخص می‌کنند، برای ذخیره وضعیت نیازی به سیستم‌عامل ندارند. در عوض، آن‌ها می‌توانند دقیقاً حالتی را که برای ادامه نیاز دارند، قبل از توقف خود ذخیره کنند، که اغلب منجر به عملکرد بهتر می‌شود. به عنوان مثال، کاری که به تازگی یک محاسبات پیچیده را به پایان رسانده است، ممکن است فقط نیاز به پشتیبان‌گیری از نتیجه نهایی محاسبات داشته باشد، زیرا دیگر به نتایج میانی نیاز ندارد.

پیاده‌سازی‌های پشتیبانی شده توسط زبان از وظایف مشارکتی، اغلب حتی قادر به پشتیبان‌گیری از قسمت‌های مورد نیاز پشته فراخوانی قبل از وقفه هستند. به عنوان مثال، اجرای async/await راست همه متغیرهای محلی را که هنوز در یک ساختمان‌ تولید شده به طور خودکار مورد نیاز هستند ذخیره می‌کند (به زیر مراجعه کنید). با پشتیبان‌گیری از قسمت‌های مربوطه پشته فراخوانی قبل از وقفه، همه وظایف می‌توانند یک پشته فراخوانی را به اشتراک بگذارند که منجر به مصرف حافظه بسیار کمتر در هر وظیفه می‌شود. این امکان ایجاد تعداد تقریبا دلخواه از وظایف مشارکتی را بدون تمام شدن حافظه فراهم می‌کند.

#### گفتگو

اشکال چند وظیفه‌ای مشارکتی این است که یک وظیفه که همکاری نمی‌کند، می‌تواند به طور بالقوه برای مدت زمان نامحدودی اجرا شود. بنابراین، یک وظیفه مخرب یا باگ می‌تواند از اجرای سایر وظایف جلوگیری کند و کل سیستم را کند یا حتی مسدود کند. به همین دلیل، چند وظیفه‌ای مشارکتی تنها زمانی باید استفاده شود که همه وظایف با هم همکاری کنند. به عنوان مثال، این ایده خوبی نیست که سیستم‌عامل را به همکاری برنامه‌های سطح کاربر دلخواه متکی کنیم.

با این حال، عملکرد قوی و مزایای حافظه چند وظیفه‌ای مشترک، آن را به یک رویکرد خوب برای استفاده در یک برنامه، به ویژه در ترکیب با عملیات ناهمزمان تبدیل می‌کند. از آن‌جایی که یک هسته سیستم‌عامل یک برنامه حیاتی برای عملکرد است که با سخت افزار ناهمزمان تعامل دارد، به نظر می‌رسد چند وظیفه‌ای مشارکتی یک رویکرد خوب برای اجرای همزمانی باشد.

## مبحث Async/Await در راست

زبان راست پشتیبانی فوق‌العاده‌ای را برای چند وظیفه‌ای مشترک در قالب async/await فراهم می‌کند. قبل از اینکه بتوانیم به بررسی async/await و نحوه کار آن بپردازیم، باید بدانیم که _فیوچرها_ (Futures) و برنامه‌نویسی ناهمزمان در راست چگونه کار می‌کند.

### فیوچرها

یک _future_ مقداری را نشان می‌دهد که ممکن است هنوز در دسترس نباشد. این می‌تواند برای مثال یک عدد صحیح باشد که توسط وظیفه دیگری محاسبه می‌شود یا فایلی که از شبکه دانلود می‌شود. به جای منتظر ماندن تا زمانی که مقدار در دسترس قرار گیرد، فیوچرها ادامه اجرا را تا زمانی که مقدار مورد نیاز شود، ممکن می‌سازد.

#### مثال

مفهوم فیوچرها به بهترین شکل با یک مثال کوچک نشان داده می‌شود:

![Sequence diagram: main calls `read_file` and is blocked until it returns; then it calls `foo()` and is also blocked until it returns. The same process is repeated, but this time `async_read_file` is called, which directly returns a future; then `foo()` is called again, which now runs concurrently to the file load. The file is available before `foo()` returns.](async-example.svg)

این نمودار دنباله‌ای، یک تابع `main` را نشان می‌دهد که یک فایل را از سیستم فایل می‌خواند و سپس تابع که نام آن را `foo` در نظر گرفته‌ شده را فراخوانی می‌کند. این فرآیند دو بار تکرار می‌شود: ابتدا با یک فراخوانی همزمان `read_file` و بار دیگر با فراخوانی ناهمزمان `async_read_file`.

با فراخوانی همزمان، تابع `main` باید منتظر بماند تا فایل از سیستم فایل بارگذاری شود. فقط در این صورت می‌تواند تابع `foo` را فراخوانی کند، که باید دوباره منتظر نتیجه بماند.

با فراخوانی ناهمزمان `async_read_file`، سیستم فایل مستقیماً یک فیوچر را برمی‌گرداند و فایل را به‌صورت ناهمزمان در پس‌زمینه بارگذاری می‌کند. این به تابع `main` اجازه می‌دهد تا `foo` را خیلی زودتر فراخوانی کند، که سپس به موازات بارگذاری فایل اجرا می شود. در این مثال، بارگذاری فایل حتی قبل از بازگشت `foo` تمام می‌شود، بنابراین `main` می‌تواند مستقیماً بدون انتظار بیشتر پس از بازگشت `foo`، با فایل کار کند.

#### فیوچرها در راست

در راست، فیوچرها با صفت [`Future`] نشان داده می‌شوند که به شکل زیر است:

[`Future`]: https://doc.rust-lang.org/nightly/core/future/trait.Future.html

```rust
pub trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}
```

مقدار `Output` [نوع مرتبط]، نوعِ مقدار ناهمزمان را مشخص می‌کند. به عنوان مثال، تابع `async_read_file` در نمودار بالا، یک نمونه`Future` را با `Output` بر روی `File` برمی‌گرداند.

[نوع مرتبط]: https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types

متد [`poll`] اجازه می‌دهد تا بررسی کنید که آیا مقدار از قبل موجود است یا خیر. یک [`Poll`] از نوع enum را برمی‌گرداند که به شکل زیر است:

[`poll`]: https://doc.rust-lang.org/nightly/core/future/trait.Future.html#tymethod.poll
[`Poll`]: https://doc.rust-lang.org/nightly/core/task/enum.Poll.html

```rust
pub enum Poll<T> {
    Ready(T),
    Pending,
}
```

هنگامی که مقدار از قبل در دسترس است (مثلاً فایل به طور کامل از دیسک خوانده شده است)، در دسته `Ready` پیچیده شده و برگردانده می‌شود. در غیر این صورت، دسته `Pending` برگردانده می‌شود، که به فراخواننده سیگنال می‌دهد که مقدار هنوز در دسترس نیست.

متد `poll` دو آرگومان دارد: `self: Pin<&mut Self>` و `cx: &mut Context`. اولی مانند یک مرجع عادی `&mut self` عمل می‌کند، با این تفاوت که مقدار `Self` به مکان حافظه آن [_پین_] شده است. درک `Pin` و چرایی نیاز آن بدون درک نحوه عملکرد async/await در ابتدا دشوار است. بنابراین در ادامه این پست به توضیح آن خواهیم پرداخت.

[_پین_]: https://doc.rust-lang.org/nightly/core/pin/index.html

هدف از پارامتر `cx: &mut Context` این است که یک نمونه [`Waker`] را به وظیفه ناهمزمان ارسال کند، به عنوان مثال، بارگذاری سیستم فایل. این`Waker` به وظیفه ناهمزمان اجازه می‌دهد تا نشان دهد که آن (یا بخشی از آن) تمام شده است، به عنوان مثال، که فایل از دیسک بارگذاری شده است. از آن‌جایی که وظیفه اصلی می‌داند که وقتی `Future` آماده شد به آن اطلاع داده می‌شود، نیازی به فراخوانی مکرر `poll` نیست. بعداً در این پست زمانی که نوع waker خودمان را پیاده‌سازی می‌کنیم، این فرآیند را با جزئیات بیشتری توضیح خواهیم داد.

[`Waker`]: https://doc.rust-lang.org/nightly/core/task/struct.Waker.html

### کار با فیوچرها

اکنون می‌دانیم که فیوچرها چگونه تعریف می‌شوند و ایده اصلی پشت متد `poll` را درک می‌کنیم. با این حال، ما هنوز نمی‌دانیم چگونه به طور موثر با فیوچرها کار کنیم. مشکل این است که فیوچرها نتایج وظیفه‌های ناهمزمان را نشان می‌دهند که ممکن است هنوز در دسترس نباشند. اما در عمل، ما اغلب برای محاسبات بیشتر به این مقادیر نیاز داریم. بنابراین سؤال این است: چگونه می‌توانیم مقدار یک فیوچر را در زمانی که به آن نیاز داریم، به طور مؤثر بازیابی کنیم؟

#### منتظر فیوچرها ماندن

یک پاسخِ ممکن این است که صبر کنید تا یک فیوچر آماده شود. این مورد می‌تواند چیزی شبیه به کد زیر باشد:

```rust
let future = async_read_file("foo.txt");
let file_content = loop {
    match future.poll(…) {
        Poll::Ready(value) => break value,
        Poll::Pending => {}, // do nothing
    }
}
```

در اینجا ما _فعالانه_ با فراخوانی مکرر `poll` در یک حلقه منتظر فیوچر هستیم. آرگومان‌های ورودی `poll` در اینجا مهم نیست، بنابراین آن‌ها را از قلم انداختیم. در حالی که این راه حل کار می‌کند، بسیار ناکارآمد است زیرا ما CPU را تا زمانی که مقدار در دسترس قرار گیرد مشغول نگه می‌داریم.

یک رویکرد کارآمدتر می‌تواند این باشد که نخ فعلی را _بلاک_ کنید تا زمانی که فیوچر در دسترس قرار گیرد. البته این فقط در صورتی امکان پذیر است که نخ‌ها را داشته باشید، بنابراین این راه حل حداقل در حال حاضر برای هسته ما کار نمی‌کند. حتی در سیستم‌هایی که بلاک کردن پشتیبانی می‌شود، این کار اغلب مطلوب نیست، زیرا یک کار ناهمزمان را دوباره به یک کار همزمان تبدیل می‌کند و در نتیجه از مزایای عملکرد بالقوه وظایف موازی جلوگیری می‌کند.

#### ترکیب کننده‌های فیوچر

جایگزینی برای انتظار، استفاده از ترکیب‌کننده‌های (combinators) فیوچر است. ترکیب‌کننده‌های فیوچر متدهایی مانند `map` هستند که امکان زنجیره‌سازی و ترکیب فیوچرها را با هم، شبیه به متدهای [`Iterator`] فراهم می‌کنند. این ترکیب‌کننده‌ها به‌جای منتظر ماندن برای فیوچر، خودشان آن را برمی‌گردانند که عملیات نگاشت را روی`poll` اعمال می‌کند.

[`Iterator`]: https://doc.rust-lang.org/stable/core/iter/trait.Iterator.html

به عنوان مثال، یک ترکیب‌کننده ساده `string_len` برای تبدیل`Future<Output = String>` به `Future<Output = usize>` می‌تواند به شکل زیر باشد:

```rust
struct StringLen<F> {
    inner_future: F,
}

impl<F> Future for StringLen<F> where F: Future<Output = String> {
    type Output = usize;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<T> {
        match self.inner_future.poll(cx) {
            Poll::Ready(s) => Poll::Ready(s.len()),
            Poll::Pending => Poll::Pending,
        }
    }
}

fn string_len(string: impl Future<Output = String>)
    -> impl Future<Output = usize>
{
    StringLen {
        inner_future: string,
    }
}

// Usage
fn file_len() -> impl Future<Output = usize> {
    let file_content_future = async_read_file("foo.txt");
    string_len(file_content_future)
}
```

این کد به صورت کامل کار نمی‌تواند کار کند زیرا [_pinning_] را کنترل نمی‌کند، اما به عنوان یک مثال کافی است. ایده اصلی این است که تابع `string_len` یک نمونه `Future` داده شده را در ساختمان‌ `StringLen` جدید قرار می‌دهد، که `Future` را نیز پیاده‌سازی می‌کند. هنگامی که فیوچر بسته‌بندی شده مورد نظرسنجی قرار می‌گیرد، فیوچر درونی را مورد نظرسنجی قرار می‌دهد. اگر مقدار هنوز آماده نیست، `Poll::Pending` نیز از فیوچر بسته‌بندی شده برگردانده می‌شود. اگر مقدار آماده باشد، رشته از نوع `Poll::Ready` استخراج می‌شود و طول آن محاسبه می‌گردد. سپس دوباره در `Poll::Ready` بسته‌بندی شده و برگردانده می‌شود.

[_pinning_]: https://doc.rust-lang.org/stable/core/pin/index.html

با این تابع `string_len`، می‌توانیم طول یک رشته ناهمزمان را بدون منتظر ماندن برای آن محاسبه کنیم. از آن‌جایی که تابع دوباره یک `Future` برمی‌گرداند، فراخواننده نمی‌تواند مستقیماً روی مقدار برگشتی کار کند، اما باید دوباره از توابع ترکیب‌کننده استفاده کند. به این ترتیب، کل گراف فراخوانی ناهمزمان می‌شود و می‌توانیم به طور موثر در یک نقطه منتظر چندین فیوچر باشیم، به عنوان مثال، در عملکرد اصلی.

نوشتن دستی توابع ترکیب‌کننده دشوار است، بنابراین آن‌ها اغلب توسط کتابخانه‌ها ارائه می‌شوند. در حالی که خود کتابخانه استاندارد راست هنوز هیچ متد ترکیب‌کننده‌ای را ارائه نمی‌دهد، کریت نیمه رسمی (و سازگار با `no_std`) [`futures`] این کار را انجام می‌دهد. صفت [`FutureExt`] آن متدهای ترکیب‌کننده سطح بالا مانند [`map`] یا [`then`] را ارائه می‌کند که می‌توان از آن برای دستکاری نتیجه با بسته‌های (closures) دلخواه استفاده کرد.

[`futures`]: https://docs.rs/futures/0.3.4/futures/
[`FutureExt`]: https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html
[`map`]: https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html#method.map
[`then`]: https://docs.rs/futures/0.3.4/futures/future/trait.FutureExt.html#method.then

##### مزایا

مزیت بزرگ ترکیب‌کننده‌های فیوچر این است که عملیات را ناهمزمان نگه می‌دارند. در ترکیب با رابط‌های ورودی/خروجی ناهمزمان، این رویکرد می‌تواند به عملکرد بسیار بالایی منجر شود. این واقعیت که ترکیب‌کننده‌های فیوچر به‌عنوان ساختمان‌های (structs) معمولی با پیاده‌سازی صفت پیاده‌سازی می‌شوند، به کامپایلر اجازه می‌دهد تا آن‌ها را بیش از حد بهینه کند. برای جزئیات بیشتر، به پست [_Zero-cost futures in Rust_] مراجعه کنید، که از اضافه شدن فیوچرها به اکوسیستم راست خبر داد.

[_Zero-cost futures in Rust_]: https://aturon.github.io/blog/2016/08/11/futures/

##### معایب {#cons}

در حالی که ترکیب‌کننده‌های فیوچر، نوشتن کدهای بسیار کارآمد را ممکن می‌سازند، استفاده از آن‌ها در برخی شرایط به دلیل سیستمِ نوع و رابط مبتنی بر closure، ممکن است دشوار باشد. به عنوان مثال، کدی مانند این را در نظر بگیرید:

```rust
fn example(min_len: usize) -> impl Future<Output = String> {
    async_read_file("foo.txt").then(move |content| {
        if content.len() < min_len {
            Either::Left(async_read_file("bar.txt").map(|s| content + &s))
        } else {
            Either::Right(future::ready(content))
        }
    })
}
```

([Try it on the playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=91fc09024eecb2448a85a7ef6a97b8d8))

در اینجا فایل `foo.txt` را می‌خوانیم و سپس از ترکیب‌کننده [`then`] برای زنجیره‌بندی فیوچر دوم بر اساس محتوای فایل استفاده می‌کنیم. اگر طول محتوا از `min_len` داده شده کوچکتر باشد، فایل `bar.txt` دیگری را می‌خوانیم و با استفاده از ترکیب‌کننده [`map`] به `content` اضافه می‌کنیم. در غیر این صورت فقط محتوای `foo.txt` را برمی‌گردانیم.

ما باید از [`move` keyword] برای closure ارسال شده به `then` استفاده کنیم زیرا در غیر این صورت یک خطای lifetime برای `min_len` وجود خواهد داشت. دلیل بسته‌بندی [`Either`] این است که بلاک‌های if و else باید همیشه یک نوع داشته باشند. از آن‌جایی که ما انواع مختلف فیوچر را در بلاک‌ها برمی‌گردانیم، باید از نوع wrapper برای یکسان سازی آن‌ها در یک نوعِ واحد استفاده کنیم. تابع [`ready`] یک مقدار را در فیوچری قرار می دهد که بلافاصله آماده است. تابع در اینجا مورد نیاز است زیرا بسته‌بندی `Either` انتظار دارد که مقدار بسته‌بندی شده `Future` را پیاده‌سازی کند.

[`move` keyword]: https://doc.rust-lang.org/std/keyword.move.html
[`Either`]: https://docs.rs/futures/0.3.4/futures/future/enum.Either.html
[`ready`]: https://docs.rs/futures/0.3.4/futures/future/fn.ready.html

همانطور که می‌توانید تصور کنید، این می‌تواند به سرعت به کدهای بسیار پیچیده برای پروژه‌های بزرگتر منجر شود. اگر قرض‌گرفتن (borrowing) و طول عمرهای (lifetimes) مختلف وجود داشته باشد، بسیار پیچیده‌تر خواهد شد. به همین دلیل، کار بسیار زیادی برای افزودن پشتیبانی از async/await به راست با هدف ساده‌تر کردن نوشتن کدهای ناهمزمان انجام شد.

### الگوری Async/Await

ایده پشت async/await این است که به برنامه‌نویس اجازه داده شود کدی بنویسد که شبیه کدهای همگام معمولی به نظر می‌رسد، اما توسط کامپایلر به کد ناهمزمان تبدیل می‌شود. این بر اساس دو کلمه کلیدی `async` و `await` کار می‌کند. کلمه کلیدی `async` را می‌توان در امضای تابع استفاده کرد تا یک تابع همزمان را به یک تابع ناهمزمان تبدیل کند که فیوچر را برمی‌گرداند:

```rust
async fn foo() -> u32 {
    0
}

// the above is roughly translated by the compiler to:
fn foo() -> impl Future<Output = u32> {
    future::ready(0)
}
```

این کلمه کلیدی به تنهایی چندان مفید نخواهد بود. با این حال، در داخل توابع `async`، از کلمه کلیدی `await` می‌توان برای بازیابی مقدار ناهمزمانِ فیوچر استفاده کرد:

```rust
async fn example(min_len: usize) -> String {
    let content = async_read_file("foo.txt").await;
    if content.len() < min_len {
        content + &async_read_file("bar.txt").await
    } else {
        content
    }
}
```

([Try it on the playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=d93c28509a1c67661f31ff820281d434))

این تابع یک ترجمه مستقیم از تابع `example` است که از توابع ترکیب‌کننده‌ای که در [بالا](#cons) دیدید استفاده می‌کند. با استفاده از عملگر `.await`، می‌توانیم مقدار یک فیوچر را بدون نیاز به closureها یا انوع `Either` بازیابی کنیم. در نتیجه، می‌توانیم کد خود را مانند کدهای همزمان معمولی بنویسیم، با این تفاوت که _همچنان کد ناهمزمان است_.

#### تبدیل ماشین حالت

کاری که کامپایلر در پشت صحنه انجام می‌دهد این است که بدنه تابع `async` را به یک [_state machine_] تبدیل می‌کند، با هر فراخوانی `.await` حالتی متفاوت را نشان می‌دهد. برای تابع `example` بالا، کامپایلر یک ماشین حالت با چهار حالت زیر ایجاد می‌کند:

[_state machine_]: https://en.wikipedia.org/wiki/Finite-state_machine

![Four states: start, waiting on foo.txt, waiting on bar.txt, end](async-state-machine-states.svg)

هر حالت نشان‌دهنده نقطه وقفه متفاوتی از تابع است. حالت‌های _"Start"_ و _"End"_ تابع را به ترتیب در ابتدا و انتهای اجرای آن نشان می‌دهند. حالت _"Waiting on foo.txt"_ نشان می‌دهد که تابع در حال حاضر منتظر اولین نتیجه `async_read_file` است. به طور مشابه، وضعیت _"Waiting on bar.txt"_ نشان‌دهنده نقطه توقفی است که تابع منتظر دومین نتیجه `async_read_file`  است.

ماشین حالت، صفت `Future` را با ایجاد هر فراخوانی `poll` یک انتقال وضعیت ممکن پیاده‌سازی می‌کند:

![Four states: start, waiting on foo.txt, waiting on bar.txt, end](async-state-machine-basic.svg)

این نمودار از فلش ها برای نشان دادن سوئیچ های حالت و اشکال الماس برای نشان دادن راه‌های جایگزین استفاده می‌کند. به عنوان مثال، اگر فایل `foo.txt` آماده نباشد، مسیر مشخص شده با _"no"_ در پیش گرفته شده و به حالت _"Waiting on foo.txt"_ می‌رسد. در غیر این صورت مسیر _"yes"_ طی می‌شود. الماس قرمز کوچک بدون شرح، شاخه `if content.len() < 100` از تابع `example` را نشان می‌دهد.

می‌بینیم که اولین فراخوانی `poll` تابع را شروع می‌کند و اجازه می‌دهد که تابع  اجرا شود تا به فیوچری برسد که هنوز آماده نیست. اگر همه فیوچرهای موجود در مسیر آماده باشند، تابع می‌تواند تا حالت _"End"_ اجرا شود، جایی که نتیجه خود را در `Poll::Ready` برمی‌گرداند. در غیر این صورت، ماشین حالت وارد حالت انتظار می‌شود و `Poll::Pending` را برمی‌گرداند. در فراخوانی بعدی `poll`، ماشین حالت از آخرین حالت انتظار شروع کرده و آخرین عملیات را دوباره امتحان می‌کند.

#### ذخیره کردن وضعیت

برای اینکه بتواند از آخرین حالت انتظار ادامه دهد، ماشین حالت باید وضعیت فعلی را درون خودش پیگیری و دنبال کند. علاوه بر این، باید تمام متغیرهایی را که برای ادامه اجرا در فراخوانی بعدی `poll` نیاز دارد، ذخیره کند. اینجاست که کامپایلر می‌تواند واقعاً بدرخشد: از آن‌جایی که می‌داند چه زمانی از کدام متغیرها استفاده می‌شود، می‌تواند به طور خودکار ساختمان‌هایی را دقیقاً با متغیرهای مورد نیاز تولید کند.

به عنوان مثال، کامپایلر ساختمان‌هایی مانند زیر را برای تابع `example` بالا تولید می‌کند:

```rust
// The `example` function again so that you don't have to scroll up
async fn example(min_len: usize) -> String {
    let content = async_read_file("foo.txt").await;
    if content.len() < min_len {
        content + &async_read_file("bar.txt").await
    } else {
        content
    }
}

// The compiler-generated state structs:

struct StartState {
    min_len: usize,
}

struct WaitingOnFooTxtState {
    min_len: usize,
    foo_txt_future: impl Future<Output = String>,
}

struct WaitingOnBarTxtState {
    content: String,
    bar_txt_future: impl Future<Output = String>,
}

struct EndState {}
```
در حالت های "start" و _"Waiting on foo.txt"_، پارامتر `min_len` باید ذخیره شود زیرا بعدا برای مقایسه با `content.len()` لازم است. حالت _"Waiting on foo.txt"_ علاوه بر این، `foo_txt_future` را نیز ذخیره می‌کند، که نشان‌دهنده فیوچری است که با فراخوانی `async_read_file` برمی‌گردد. وقتی ماشین ادامه می‌یابد، این فیوچر باید دوباره بررسی شود، بنابراین باید ذخیره شود.

حالت _"Waiting on bar.txt"_ حاوی متغیر `content` است زیرا پس از آماده شدن `bar.txt` برای الحاق رشته مورد نیاز است. همچنین یک `bar_txt_future` را ذخیره می‌کند که نشان‌دهنده در حال پیشرفت بودن `bar.txt` است. ساختمان‌ حاوی متغیر `min_len` نیست زیرا پس از مقایسه `content.len()` دیگر به آن نیازی نیست. در حالت _"end"_، هیچ متغیری ذخیره نمی‌شود زیرا تابع قبلاً به صورت کامل اجرا شده است.

به خاطر داشته باشید که این فقط یک نمونه برای کدی است که کامپایلر می‌تواند ایجاد کند. نام struct و طرح فیلد، جزییات پیاده‌سازی هستند و ممکن است متفاوت باشند.

#### نوع ماشین حالت کامل

در حالی که کد دقیق تولید شده توسط کامپایلر یک جزئیات پیاده‌سازی است، به درک اینکه چگونه ماشین حالت تولید شده _می‌تواند_ به دنبال تابع `example` بگردد، کمک می‌کند. ما قبلاً ساختمان‌هایی را تعریف کرده‌ایم که حالت‌های مختلف را نشان می‌دهند و شامل متغیرهای مورد نیاز هستند. برای ایجاد یک ماشین حالت بر روی آن‌ها، می‌توانیم آن‌ها را در یک [`enum`] ترکیب کنیم:

[`enum`]: https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html

```rust
enum ExampleStateMachine {
    Start(StartState),
    WaitingOnFooTxt(WaitingOnFooTxtState),
    WaitingOnBarTxt(WaitingOnBarTxtState),
    End(EndState),
}
```

ما برای هر حالت یک نوع enum جداگانه تعریف می‌کنیم و ساختمان حالت مربوطه را به عنوان یک فیلد به هر یک از متغیرها اضافه می‌کنیم. برای پیاده‌سازی انتقال حالت، کامپایلر یک پیاده‌سازی از صفت `Future` را بر اساس تابع `example` ایجاد می‌کند:

```rust
impl Future for ExampleStateMachine {
    type Output = String; // return type of `example`

    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {
        loop {
            match self { // TODO: handle pinning
                ExampleStateMachine::Start(state) => {…}
                ExampleStateMachine::WaitingOnFooTxt(state) => {…}
                ExampleStateMachine::WaitingOnBarTxt(state) => {…}
                ExampleStateMachine::End(state) => {…}
            }
        }
    }
}
```

نوع `Output` مربوط به فیوچر از نوع `String` است زیرا نوع برگشتی تابع `example` است. برای پیاده‌سازی تابع `poll`، از یک عبارت مطابقت (match statement) در وضعیت فعلی درون `loop` استفاده می‌کنیم. ایده این است که تا امکان دارد به حالت بعدی تغییر وضعیت دهیم و زمانی که نمی‌توانیم ادامه دهیم از یک `return Poll::Pending` صریح استفاده کنیم.

برای سادگی، فقط کد ساده شده را نشان می‌دهیم و [پین کردن][_pinning_]، مالکیت، طول عمر و غیره را بررسی نمی‌کنیم. بنابراین این کد و کد زیر باید به‌عنوان شبه کد در نظر گرفته شوند و مستقیماً استفاده نشوند. البته، کد تولید شده توسط کامپایلر واقعی همه چیز را به درستی مدیریت می‌کند، هر چند احتمالاً به روشی متفاوت.

برای کوچک نگه داشتن گزیده کد، کد را برای هر بازوی مسابقه به طور جداگانه ارائه می‌کنیم. بیایید با حالت `Start` شروع کنیم:

```rust
ExampleStateMachine::Start(state) => {
    // from body of `example`
    let foo_txt_future = async_read_file("foo.txt");
    // `.await` operation
    let state = WaitingOnFooTxtState {
        min_len: state.min_len,
        foo_txt_future,
    };
    *self = ExampleStateMachine::WaitingOnFooTxt(state);
}
```

وقتی ماشین حالت درست در ابتدای تابع باشد در حالت `Start` است. در این حالت، تمام کدها را از بدنه تابع `example` تا اولین`.await` اجرا می‌کنیم. برای انجام عملیات `.await`، وضعیت ماشین حالت `self` را به `WaitingOnFooTxt` تغییر می‌دهیم که شامل ساختن ساختمان `WaitingOnFooTxtState` است.

از آن‌جایی که عبارت `match self {…}` در یک حلقه اجرا می‌شود، اجرا به بازوی `WaitingOnFooTxt` در مرحله بعد می‌پرد:

```rust
ExampleStateMachine::WaitingOnFooTxt(state) => {
    match state.foo_txt_future.poll(cx) {
        Poll::Pending => return Poll::Pending,
        Poll::Ready(content) => {
            // from body of `example`
            if content.len() < state.min_len {
                let bar_txt_future = async_read_file("bar.txt");
                // `.await` operation
                let state = WaitingOnBarTxtState {
                    content,
                    bar_txt_future,
                };
                *self = ExampleStateMachine::WaitingOnBarTxt(state);
            } else {
                *self = ExampleStateMachine::End(EndState);
                return Poll::Ready(content);
            }
        }
    }
}
```

در این بازوی تطبیق، ابتدا تابع `poll` از `foo_txt_future` را فراخوانی می‌کنیم. اگر آماده نیست، از حلقه خارج می‌شویم و `Poll::Pending` را برمی‌گردانیم. از آن‌جایی که `self` در این مورد در حالت`WaitingOnFooTxt` باقی می‌ماند، فراخوان `poll` بعدی در ماشین حالت وارد همان بازوی تطبیقی می‌شود و دوباره سعی می‌کند `foo_txt_future` را نظرسنجی کند.

وقتی `foo_txt_future` آماده شد، نتیجه را به متغیر `content` اختصاص می‌دهیم و به اجرای کد تابع `example` ادامه می‌دهیم: اگر `content.len()` کوچک‌تر از `min_len` ذخیره شده در ساختمان حالت باشد، فایل `bar.txt` به صورت ناهمزمان خوانده می‌شود. مجدداً عملیات `.await` را به یک تغییر حالت ترجمه می‌کنیم، این بار به حالت `WaitingOnBarTxt`. از آن‌جایی که ما `match` را در داخل یک حلقه اجرا می‌کنیم، اجرا مستقیماً به بازوی تطبیق برای حالت جدید پس از آن می‌پرد، جایی که `bar_txt_future` نظرسنجی می‌شود.

در صورتی که وارد شاخه `else` شویم، دیگر عملیات `انتظار` انجام نمی‌شود. به انتهای تابع می‌رسیم و `content` بسته‌بندی شده در `Poll::Ready` را برمی‌گردانیم. همچنین حالت فعلی را به حالت `End` تغییر می‌دهیم.

کد حالت `WaitingOnBarTxt` به شکل زیر است:

```rust
ExampleStateMachine::WaitingOnBarTxt(state) => {
    match state.bar_txt_future.poll(cx) {
        Poll::Pending => return Poll::Pending,
        Poll::Ready(bar_txt) => {
            *self = ExampleStateMachine::End(EndState);
            // from body of `example`
            return Poll::Ready(state.content + &bar_txt);
        }
    }
}
```

مشابه حالت `WaitingOnFooTxt`، با نظرسنجی `bar_txt_future` شروع می‌کنیم. اگر هنوز در حال تعلیق است، از حلقه خارج می‌شویم و `Poll::Pending` را برمی‌گردانیم. در غیر این صورت، می‌توانیم آخرین عملیات تابع `example` را انجام دهیم: الحاق متغیر `content` به نتیجه فیوچر. ماشین حالت را به حالت `End` به‌روزرسانی می‌کنیم و سپس نتیجه بسته‌بندی شده در `Poll::Ready` را برمی‌گردانیم.

در نهایت، کد حالت `End` به شکل زیر است:

```rust
ExampleStateMachine::End(_) => {
    panic!("poll called after Poll::Ready was returned");
}
```

پس از بازگشت `Poll::Ready`، فیوچرها نباید دوباره نظرسنجی شوند، بنابراین اگر زمانی که در حالت `End` هستیم، `poll` فراخوانی شود، پنیک می‌کنیم.

اکنون می‌دانیم که ماشین حالت تولید شده توسط کامپایلر و اجرای آن از صفت `Future` چگونه _می‌تواند_ باشد. در عمل، کامپایلر کد را به روشی متفاوت تولید می‌کند. (در صورت علاقه، پیاده‌سازی فعلی بر اساس [_generators_] است، اما این فقط یک جزئیات پیاده‌سازی است.)

[_generators_]: https://doc.rust-lang.org/nightly/unstable-book/language-features/generators.html

آخرین قطعه از پازل، کد تولید شده برای خود تابع `example` است. به یاد داشته باشید که هِدِر تابع به صورت زیر تعریف شده است:

```rust
async fn example(min_len: usize) -> String
```

از آن‌جایی که اکنون کاملا بدنه تابع توسط ماشین حالت پیاده‌سازی شده است، تنها کاری که تابع باید انجام دهد این است که ماشین حالت را مقداردهی اولیه کرده و آن را برگرداند. کد تولید شده برای این می‌تواند به شکل زیر باشد:

```rust
fn example(min_len: usize) -> ExampleStateMachine {
    ExampleStateMachine::Start(StartState {
        min_len,
    })
}
```

این تابع دیگر اصلاح‌کننده `async` ندارد زیرا اکنون به صراحت نوع `ExampleStateMachine` را برمی‌گرداند که صفت `Future` را پیاده‌سازی می‌کند. همانطور که انتظار می‌رود، ماشین حالت در حالت `Start` ساخته می‌شود و ساختمان حالت مربوطه با پارامتر `min_len` مقداردهی اولیه می‌شود.

توجه داشته باشید که این تابع، اجرای ماشین حالت را شروع نمی‌کند. این یک تصمیم اساسی برای طراحی فیوچرها در راست است: آن‌ها تا زمانی که برای اولین بار در نظرسنجی قرار نگیرند کاری انجام نمی‌دهند.

### Pinning

قبلاً در این پست چندین بار با _pinning_ برخورد کرده‌ایم. اکنون بالاخره زمان آن رسیده است که ببینیم پین کردن چیست و چرا به آن نیاز است.

#### Self-Referential Structs

همانطور که در بالا توضیح داده شد، تبدیل ماشین حالت، متغیرهای محلی هر نقطه وقفه را در یک ساختمان ذخیره می‌کند. برای مثال‌های کوچکی مانند تابع `example`، این کار ساده بود و به هیچ مشکلی منجر نشد. با این حال، وقتی متغیرها به یکدیگر ارجاع می‌دهند، همه چیز دشوارتر می‌شود. برای مثال این تابع را در نظر بگیرید:

```rust
async fn pin_example() -> i32 {
    let array = [1, 2, 3];
    let element = &array[2];
    async_write_file("foo.txt", element.to_string()).await;
    *element
}
```

این تابع یک `array` کوچک با محتویات `1`، `2` و `3` ایجاد می‌کند. سپس یک مرجع به آخرین عنصر آرایه ایجاد می‌کند و آن را در یک متغیر `element` ذخیره می‌کند. سپس به صورت ناهمزمان عدد تبدیل شده به رشته را به فایل `foo.txt` می نویسد. در نهایت، عدد ارجاع شده توسط "element" را برمی‌گرداند.

از آن‌جایی که تابع از یک عملیات `await` استفاده می‌کند، ماشین حالتِ حاصل، سه حالت دارد: شروع، پایان و "منتظر نوشتن". تابع هیچ آرگومانی نمی‌گیرد، بنابراین ساختمان برای حالت شروع خالی است. مانند قبل، ساختمان حالت پایانی نیز خالی است زیرا تابع در این نقطه به پایان رسیده است. ساختمان حالت "منتظر نوشتن" جالب‌تر است:

```rust
struct WaitingOnWriteState {
    array: [1, 2, 3],
    element: 0x1001c, // address of the last array element
}
```

ما باید هر دو متغیر `array` و `element` را ذخیره کنیم زیرا `element` برای مقدار بازگشتی مورد نیاز است و `array` با `element` ارجاع می‌شود. از آن‌جایی که "element" یک مرجع است، یک _pointer_ (یعنی یک آدرس حافظه) را در عنصر ارجاع شده ذخیره می‌کند. در اینجا از `0x1001c` به عنوان نمونه آدرس حافظه استفاده کردیم. در واقع باید آدرس آخرین عنصر فیلد `array` باشد، بنابراین بستگی به محل قرار گرفتن ساختمان در حافظه دارد. ساختمان‌هایی با چنین اشاره‌گرهای داخلی، ساختمان‌های _خود ارجاعی_ (self-referential) نامیده می‌شوند زیرا آن‌ها خود را از یکی از فیلدهایشان ارجاع می‌دهند.

#### مشکل ساختمان‌های خودارجاعی

اشاره‌گر داخلی مربوط به ساختمان خود ارجاعی (self-referential) ما، منجر به یک مشکل اساسی می‌شود که وقتی به چیدمان حافظه آن نگاه می‌کنیم آشکار می‌شود:

![array at 0x10014 with fields 1, 2, and 3; element at address 0x10020, pointing to the last array element at 0x1001c](self-referential-struct.svg)

فیلد "array" از آدرس 0x10014 و فیلد `element` از آدرس 0x10020 شروع می‌شود. به آدرس 0x1001c اشاره می‌کند زیرا آخرین عنصر آرایه در این آدرس قرار گرفته دارد. در این مرحله، هنوز همه چیز خوب است. با این حال، زمانی که این ساختمان را به آدرس حافظه دیگری منتقل می‌کنیم، مشکلی رخ می‌دهد:

![array at 0x10024 with fields 1, 2, and 3; element at address 0x10030, still pointing to 0x1001c, even though the last array element now lives at 0x1002c](self-referential-struct-moved.svg)

ساختمان را کمی جابجا کردیم تا اکنون از آدرس `0x10024` شروع شود. به عنوان مثال، زمانی که ساختمان را به عنوان آرگومان تابع ارسال می‌کنیم یا آن را به یک متغیر پشته دیگر نسبت می‌دهیم، ممکن است اتفاق بیفتد. مشکل این است که فیلد `element` همچنان به آدرس `0x1001c` اشاره می‌کند، اگر چه آخرین عنصر `array` اکنون در آدرس `0x1002c` قرار دارد. بنابراین، اشاره‌گر آویزان (dangling) است و در نتیجه رفتار نامشخصی در فراخوانی بعدی `poll` رخ می‌دهد.

#### راه حل‌های ممکن 

سه رویکرد اساسی برای حل مشکل اشاره‌گر آویزان وجود دارد:

- **به روز رسانی اشاره‌گر در هنگام جابجایی:** ایده این است که هر زمان که ساختمان در حافظه جابجا می‌شود، اشاره‌گر داخلی را به روز کنید تا پس از جابجایی همچنان معتبر باشد. متأسفانه، این رویکرد مستلزم تغییرات گسترده‌ای در راست است که می‌تواند منجر به ضررهای شدیدی در عملکرد شود. چرا که نوعی زمان اجرا (runtime) باید نوع تمام فیلدهای ساختمان را پیگیری کند و در هر جابجایی بررسی کند که آیا به روز رسانی اشاره‌گر نیاز است یا خیر.
- **ذخیره یک آفست به جای ارجاع به خود:**: برای اجتناب از نیاز به به روز رسانی اشاره‌گرها، کامپایلر می‌تواند به جای آن سعی کند خود ارجاعات را به عنوان آفست از ابتدای ساختمان ذخیره کند. برای مثال، فیلد `element` ساختمان `WaitingOnWriteState` بالا را می‌توان به شکل یک فیلد `element_offset` با مقدار 8 ذخیره کرد، زیرا عنصر آرایه‌ای که مرجع به آن اشاره می‌کند، 8 بایت بعد از شروع ساختمان شروع می‌شود. از آن‌جایی که هنگام جابجایی ساختمان‌، آفست ثابت می‌ماند، نیازی به به روز رسانی فیلد نیست.

  مشکل این رویکرد این است که به کامپایلر نیاز دارد تا تمام ارجاعات خود را شناسایی کند. چنین چیزی در زمان کامپایل امکان‌پذیر نیست زیرا مقدار یک مرجع ممکن است به ورودی کاربر بستگی داشته باشد، بنابراین ما دوباره به یک سیستم زمان اجرا برای تجزیه و تحلیل مراجع و ایجاد درست ساختمان‌های حالت نیاز داریم. این نه تنها منجر به هزینه‌های زمان اجرا می‌شود، بلکه از برخی بهینه‌سازی‌های کامپایلر نیز جلوگیری می‌کند، به طوری که دوباره باعث کاهش شدید عملکرد می‌شود.
- **منع جابجایی ساختمان:** همانطور که در بالا دیدیم، اشاره‌گر آویزان تنها زمانی رخ می‌دهد که ساختمان‌ را در حافظه جابجا کنیم. با ممنوع کردن کامل عملیات جابجایی در ساختمان‌های خود ارجاعی، می‌توان از این مشکل نیز جلوگیری کرد. مزیت بزرگ این رویکرد این است که می‌توان آن را در سطح سیستم نوع (type system)، بدون هزینه‌های زمان اجرای اضافی پیاده‌سازی کرد. اشکال این روش این است که بارِ پرداختن به عملیات‌های جابجایی را بر روی ساختمان‌های احتمالاً خودارجاعی، بر عهده برنامه‌نویس قرار می‌دهد.

به دلیل اصول خود بر ارائه _zero cost abstractions_، که به این معنی است که انتزاع‌ها نباید هزینه‌های زمان اجرای اضافی را تحمیل کنند، راست راه‌حل سوم را انتخاب کرد. به این خاطر، اِی‌پی‌آیِ (API) [_پین کردن_] در [RFC 2349](https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md) پیشنهاد شد. در ادامه مروری کوتاه بر این API خواهیم داشت و نحوه عملکرد آن با async/await و فیوچرها را توضیح خواهیم داد.

#### مقادیر هیپ

اولین مشاهدات این است که مقادیر [heap allocated] در اکثر مواقع دارای آدرس حافظه ثابت هستند. آن‌ها با استفاده از فراخوانی برای `allocate` ایجاد می‌شوند و سپس با یک نوع اشاره‌گر مانند `Box<T>` ارجاع داده می‌شوند. در حالی که جابجایی نوع اشاره‌گر امکان پذیر است، مقدار هیپی که اشاره‌گر به آن اشاره می‌کند، تا زمانی که دوباره از طریق یک فراخوانی `deallocate` آزاد شود، در همان آدرس حافظه باقی می‌ماند .

[heap allocated]: @/edition-2/posts/10-heap-allocation/index.md

با استفاده از تخصیص هیپ، می‌توانیم سعی کنیم یک ساختمان‌ خود ارجاعی ایجاد کنیم:

```rust
fn main() {
    let mut heap_value = Box::new(SelfReferential {
        self_ptr: 0 as *const _,
    });
    let ptr = &*heap_value as *const SelfReferential;
    heap_value.self_ptr = ptr;
    println!("heap value at: {:p}", heap_value);
    println!("internal reference: {:p}", heap_value.self_ptr);
}

struct SelfReferential {
    self_ptr: *const Self,
}
```

([Try it on the playground][playground-self-ref])

[playground-self-ref]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ce1aff3a37fcc1c8188eeaf0f39c97e8

ما یک ساختمان‌ ساده به نام `SelfReferential` ایجاد می‌کنیم که حاوی یک فیلد اشاره‌گر است. ابتدا این ساختمان‌ را با یک اشاره‌گر تهی مقداردهی اولیه می‌کنیم و سپس با استفاده از `Box::new` آن را روی هیپ تخصیص می‌دهیم. سپس آدرس حافظه ساختمانِ تخصیص داده شده هیپ را تعیین کرده و آن را در یک متغیر `ptr` ذخیره می‌کنیم. در نهایت، ساختمان را با تخصیص متغیر `ptr` به فیلد `self_ptr` خود ارجاعی می‌کنیم.

وقتی این کد را [در زمین بازی][playground-self-ref] اجرا می‌کنیم، می‌بینیم که آدرس مقدار هیپ و اشاره‌گر داخلی آن برابر است، به این معنی که فیلد `self_ptr` یک مرجع معتبر است. از آن‌جایی که متغیر `heap_value` فقط یک اشاره‌گر است، جابجایی آن (به عنوان مثال با ارسال آن به یک تابع) آدرس ساختمان خود را تغییر نمی‌دهد، بنابراین حتی اگر اشاره‌گر جابجا شود،  `self_ptr` معتبر می‌ماند.

با این حال، هنوز راهی برای شکستن این مثال وجود دارد: می‌توانیم از یک `Box<T>` خارج شویم یا محتوای آن را جایگزین کنیم:

```rust
let stack_value = mem::replace(&mut *heap_value, SelfReferential {
    self_ptr: 0 as *const _,
});
println!("value at: {:p}", &stack_value);
println!("internal reference: {:p}", stack_value.self_ptr);
```

([Try it on the playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=e160ee8a64cba4cebc1c0473dcecb7c8))

در اینجا از تابع [`mem::replace`] برای جایگزینی مقدار تخصیص داده شده هیپ با یک نمونه ساختمان‌ جدید استفاده می‌کنیم. این به ما اجازه می‌دهد `heap_value` اصلی را به پشته منتقل کنیم، در حالی که فیلد `self_ptr` ساختمان‌ اکنون یک اشاره‌گر آویزان است که همچنان به آدرس هیپ قدیمی اشاره می‌کند. وقتی می‌خواهید مثال را در زمین بازی اجرا کنید، می‌بینید که خطوط چاپ شده _"value at:"_ و _"Internal reference:"_ اشاره‌گرهای متفاوتی را نشان می‌دهند. بنابراین تخصیص یک مقدار برای ایمن کردن خود ارجاعی کافی نیست.

[`mem::replace`]: https://doc.rust-lang.org/nightly/core/mem/fn.replace.html

مشکل اساسی که باعث شکست بالا شد این است که `Box<T>` به ما اجازه می‌دهد تا مرجع `&mut T` به مقدار تخصیص داده شده هیپ دریافت کنیم. این مرجع `&mut` استفاده از متدهایی مانند [`mem::replace`] یا [`mem::swap`] را برای باطل کردن مقدار تخصیص داده شده هیپ ممکن می‌سازد. برای حل این مشکل، باید از ایجاد ارجاعات `&mut` به ساختمان‌های خودارجاعی جلوگیری کنیم.

[`mem::swap`]: https://doc.rust-lang.org/nightly/core/mem/fn.swap.html

#### `Pin<Box<T>>` و `Unpin`

ای‌پی‌آی پین کردن، راه‌حلی برای مشکل `&mut T` به شکل نوع بسته‌بندی [`Pin`] و صفت نشانگر [`Unpin`] ارائه می‌کند. ایده پشت این انواع این است که تمام متدهای `Pin` را که می‌توان برای دریافت ارجاعات `&mut` به مقدار بسته‌بندی شده در صفت `Unpin` استفاده کرد را به دست آورد (به عنوان مثال [`get_mut`][pin-get-mut] یا [`deref_mut`][pin -deref-mut]). صفت `Unpin` یک [_auto trait_] است که به‌طور خودکار برای همه انواع به‌جز انواعی که صراحتاً انصراف می‌دهند، اجرا می‌شود. با انصراف ساختمان‌های خودارجاعی از `Unpin`، هیچ راه (ایمنی) برای دریافت `&mut T` از نوع `Pin<Box<T>>` برای آن‌ها وجود ندارد. در نتیجه، اعتبار خود ارجاعات داخلی آن‌ها تضمین می‌شود.

[`Pin`]: https://doc.rust-lang.org/stable/core/pin/struct.Pin.html
[`Unpin`]: https://doc.rust-lang.org/nightly/std/marker/trait.Unpin.html
[pin-get-mut]: https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.get_mut
[pin-deref-mut]: https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#impl-DerefMut
[_auto trait_]: https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits

به عنوان مثال، بیایید نوع `SelfReferential` که در بالا دیدیم را به روز کنیم تا از `Unpin` انصراف دهیم:

```rust
use core::marker::PhantomPinned;

struct SelfReferential {
    self_ptr: *const Self,
    _pin: PhantomPinned,
}
```

با افزودن یک فیلد `_pin` دوم از نوع [`PhantomPinned`] انصراف می‌دهیم. این نوع یک نوع نشانگر با اندازه صفر (zero-sized marker) است که تنها هدف آن پیاده‌سازی _نکردن_ صفت `Unpin` است. به دلیل نحوه کار [auto traits][_auto trait_]، یک فیلد منفرد که `Unpin` نباشد برای انصراف کامل ساختمان‌ از `Unpin` کافی است.

[`PhantomPinned`]: https://doc.rust-lang.org/nightly/core/marker/struct.PhantomPinned.html

مرحله دوم این است که نوع `Box<SelfReferential>` در مثال را به نوع `Pin<Box<SelfReferential>>` تغییر دهید. ساده‌ترین راه برای انجام این کار استفاده از تابع [`Box::pin`] به جای [`Box::new`] برای ایجاد مقدار تخصیص شده پشته است:

[`Box::pin`]: https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html#method.pin
[`Box::new`]: https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html#method.new

```rust
let mut heap_value = Box::pin(SelfReferential {
    self_ptr: 0 as *const _,
    _pin: PhantomPinned,
});
```

علاوه بر تغییر `Box::new` به `Box::pin`، باید فیلد `_pin` جدید را نیز در مقداردهی اولیه کننده (initializer) ساختمان‌ اضافه کنیم. از آن‌جایی که `PhantomPinned` یک نوع اندازه صفر است، برای مقداردهی اولیه آن فقط به نام نوعِ آن نیاز داریم.

When we [try to run our adjusted example](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=961b0db194bbe851ff4d0ed08d3bd98a) now, we see that it no longer works:

```
error[E0594]: cannot assign to data in a dereference of `std::pin::Pin<std::boxed::Box<SelfReferential>>`
  --> src/main.rs:10:5
   |
10 |     heap_value.self_ptr = ptr;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
   |
   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::pin::Pin<std::boxed::Box<SelfReferential>>`

error[E0596]: cannot borrow data in a dereference of `std::pin::Pin<std::boxed::Box<SelfReferential>>` as mutable
  --> src/main.rs:16:36
   |
16 |     let stack_value = mem::replace(&mut *heap_value, SelfReferential {
   |                                    ^^^^^^^^^^^^^^^^ cannot borrow as mutable
   |
   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::pin::Pin<std::boxed::Box<SelfReferential>>`
```

هر دو خطا به این دلیل رخ می‌دهند که نوع `Pin<Box<SelfReferential>>` دیگر صفت `DerefMut` را پیاده‌سازی نمی‌کند. این دقیقاً همان چیزی است که ما می‌خواستیم زیرا ویژگی `DerefMut` یک مرجع `&mut` را برمی‌گرداند که می‌خواهیم از آن جلوگیری کنیم. این فقط به این دلیل اتفاق می‌افتد که هر دو از `Unpin` انصراف دادیم و `Box::new` را به `Box::pin` تغییر دادیم.

مشکل اکنون این است که کامپایلر نه تنها از جابجایی نوع در خط 16 جلوگیری می‌کند، بلکه از مقداردهی اولیه فیلد `self_ptr` در خط 10 نیز جلوگیری می‌کند. زیرا کامپایلر نمی‌تواند بین استفاده معتبر و نامعتبر از ارجاعات `&mut` تفاوت قائل شود. برای اینکه مقداردهی اولیه دوباره کار کند، باید از متد ناامن [`get_unchecked_mut`] استفاده کنیم:

[`get_unchecked_mut`]: https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.get_unchecked_mut

```rust
// safe because modifying a field doesn't move the whole struct
unsafe {
    let mut_ref = Pin::as_mut(&mut heap_value);
    Pin::get_unchecked_mut(mut_ref).self_ptr = ptr;
}
```

([Try it on the playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=b9ebbb11429d9d79b3f9fffe819e2018))

تابع [`get_unchecked_mut`] به جای `Pin<Box<T>>` روی `Pin<&mut T>` کار می‌کند، بنابراین باید از [`Pin::as_mut`] برای تبدیل مقدار قبلی استفاده کنیم. سپس می‌توانیم فیلد `self_ptr` را با استفاده از مرجع `&mut` که توسط `get_unchecked_mut` برگردانده شده است، تنظیم کنیم.

[`Pin::as_mut`]: https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.as_mut

اکنون تنها خطای باقی‌مانده، خطای مورد نظر در `mem::replace` است. به یاد داشته باشید، این عملیات سعی می‌کند مقدار تخصیص داده شده هیپ را به پشته منتقل کند، که باعث می‌شود مرجع خود ارجاعی ذخیره شده در فیلد `self_ptr` شکسته شود. با انصراف از `Unpin` و استفاده از `Pin<Box<T>>`، می‌توانیم از این عملیات در زمان کامپایل جلوگیری کنیم و بنابراین با خیال راحت با ساختمان‌های خود ارجاعی کار کنیم. همانطور که دیدیم، کامپایلر نمی‌تواند ثابت کند که ایجاد خود ارجاعی ایمن است (هنوز)، بنابراین باید از یک بلاک ناامن استفاده کنیم و خودمان صحت آن را تأیید کنیم.

#### پین کردن پشته و `Pin<&mut T>`

در بخش قبل یاد گرفتیم که چگونه از `Pin<Box<T>>` برای ایجاد ایمن یک مقدار خود ارجاعی اختصاص داده شده هیپ استفاده کنیم. در حالی که این روش به خوبی کار می‌کند و نسبتاً ایمن است (به غیر از ساخت ناامن)، تخصیص هیپ مورد نیاز، تأثیر منفی روی عملکرد دارد. از آن‌جایی که راست همیشه می‌خواهد در صورت امکان _zero-cost abstractions_ را ارائه کند، API پین‌کردن همچنین اجازه می‌دهد تا نمونه‌های `Pin<&mut T>` را ایجاد کند که به مقادیر اختصاص‌یافته پشته اشاره می‌کنند.

برخلاف نمونه‌های `Pin<Box<T>>` که دارای _مالکیت_ مقدار بسته‌‌بندی شده هستند، نمونه‌های `Pin<&mut T>` فقط به‌طور موقت مقدار بسته‌‌بندی شده را قرض می‌گیرند. این کار را پیچیده‌تر می‌کند، زیرا برنامه‌نویس را ملزم می‌کند که گارانتی‌های اضافی را خودش تضمین کند. مهم‌تر از همه، یک `Pin<&mut T>` باید برای تمام طول عمر `T` ارجاع شده پین شود، که تأیید آن برای متغیرهای مبتنی بر پشته دشوار است. برای کمک به این کار، کریت‌هایی مانند [`pin-utils`] وجود دارد، اما من هنوز پین کردن به پشته را توصیه نمی‌کنم، مگر اینکه واقعاً بدانید دارید چه کار می‌کنید.

[`pin-utils`]: https://docs.rs/pin-utils/0.1.0-alpha.4/pin_utils/

برای مطالعه بیشتر، مستندات [ماژول `pin`] و متد [`Pin::new_unchecked`] را بررسی کنید.

[ماژول `pin`]: https://doc.rust-lang.org/nightly/core/pin/index.html
[`Pin::new_unchecked`]: https://doc.rust-lang.org/nightly/core/pin/struct.Pin.html#method.new_unchecked

#### پین کردن و فیوچرها

همانطور که قبلا در این پست دیدیم، متد [`Future::poll`] از پین کردن به شکل پارامتر `Pin<&mut Self>` استفاده می‌کند:

[`Future::poll`]: https://doc.rust-lang.org/nightly/core/future/trait.Future.html#tymethod.poll

```rust
fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>
```

دلیل اینکه این متد، `self: Pin<&mut Self>` را به جای `&mut self` معمولی می‌گیرد این است که نمونه‌های فیوچر‌ ایجاد شده از async/await اغلب خود ارجاعی هستند، همانطور که در [بالا][self-ref-async-await] دیدیم. با بسته‌بندی کردن `Self` در `Pin` و اجازه دادن به کامپایلر برای انصراف از `Unpin` برای فیوچر‌‌های خود ارجاعی تولید شده از async/await، تضمین می‌شود که فیوچر‌‌ها در حافظه بین فراخوانی‌های `poll` جابه‌جا نمی‌شوند. این تضمین می‌کند که همه مراجع داخلی هنوز معتبر هستند.

[self-ref-async-await]: @/edition-2/posts/12-async-await/index.md#self-referential-structs

شایان ذکر است که جابجایی فیوچرها قبل از اولین فراخوان `poll` مشکلی ندارد. این نتیجه این واقعیت است که فیوچرها تنبل هستند و تا زمانی که برای اولین بار در نظرسنجی قرار نگیرند کاری انجام نمی‌دهند. بنابراین، حالت `start` ماشین‌های حالت تولید شده فقط حاوی آرگومان‌های تابع است، اما هیچ مرجع داخلی ندارد. برای فراخوانی `poll`، فراخواننده باید ابتدا فیوچر‌ را در `Pin` بسته‌بندی کند، که تضمین می‌کند که فیوچر‌ دیگر نمی‌تواند در حافظه جابجا شود. از آن‌جایی که پین کردن پشته دشوارتر است، توصیه می‌کنم همیشه از [`Box::pin`] همراه با [`Pin::as_mut`] برای این کار استفاده کنید.

[`futures`]: https://docs.rs/futures/0.3.4/futures/

اگر علاقه‌مند به درک نحوه پیاده‌سازی ایمن یک تابع ترکیب‌کننده فیوچر‌ با استفاده از پین کردن پشته هستید، نگاهی به [منبع متد ترکیب‌کننده `map`][map-src] نسبتاً کوتاه کریت `فیوچر‌` و بخش مربوط به [طرح‌ریزی و پین‌کردن ساختاری] مستندات پین بیاندازید.

[map-src]: https://docs.rs/futures-util/0.3.4/src/futures_util/future/future/map.rs.html
[طرح‌ریزی و پین‌کردن ساختاری]: https://doc.rust-lang.org/stable/std/pin/index.html#projections-and-structural-pinning

### اجرا کننده‌ها (executors) و بیدار کننده‌ها (wakers)

با استفاده از async/await می‌توان به صورت ارگونومیک با فیوچرها به صورت کاملا ناهمزمان کار کرد. با این حال، همانطور که در بالا آموختیم، فیوچرها تا زمانی که نظرسنجی نشده‌اند، کاری انجام نمی‌دهند. زیرا ما باید در نقطه‌ای از آن‌ها `poll` را فراخوانی کنیم، در غیر این صورت کد ناهمزمان هرگز اجرا نمی‌شود.

با یک فیوچر‌ واحد، همیشه می‌توانیم با استفاده از یک حلقه [همانطور که در بالا توضیح داده شد] (#waiting-on-futures) برای هر فیوچر‌ به صورت دستی منتظر بمانیم. با این حال، این رویکرد برای برنامه‌هایی که تعداد زیادی فیوچر‌ را ایجاد می‌کنند بسیار ناکارآمد است و عملی نیست. متداول‌ترین راه حل برای این مشکل، تعریف یک _اجرا کننده‌_ سراسری است که مسئول نظرسنجی تمام فیوچرها در سیستم تا زمانی که به پایان برسند، است.

#### اجرا کننده‌ها

هدف یک اجرا کننده این است که اجازه دهد فیوچرها به عنوان وظایف مستقل، معمولاً از طریق نوعی متد `spawn` تولید شود. سپس اجرا کننده مسئول نظرسنجی همه فیوچرها تا تکمیل آن‌ها است. مزیت بزرگ مدیریت همه فیوچرها در یک مکان مرکزی این است که اجرا کننده می‌تواند هر زمان که یک فیوچر‌ `Poll::Pending` را برمی‌گرداند، به فیوچر‌ دیگری تغییر جابجا شود. بنابراین، عملیات ناهمزمان به صورت موازی اجرا می‌شود و CPU مشغول نگه داشته می‌شود.

بسیاری از پیاده‌سازی‌های اجرایی می‌توانند از مزایای سیستم‌هایی با چندین هسته CPU نیز بهره ببرند. آن‌ها یک [thread pool] ایجاد می‌کنند که می‌تواند در صورت وجود کار کافی از تمام هسته‌ها استفاده کند و از تکنیک‌هایی مانند [work stealing] برای متعادل کردن بار بین هسته‌ها استفاده می‌کند. همچنین پیاده‌سازی‌های ویژه‌ای برای سیستم‌های توکار وجود دارد که برای تأخیر کم و سربار حافظه بهینه‌سازی می‌شود.

[thread pool]: https://en.wikipedia.org/wiki/Thread_pool
[work stealing]: https://en.wikipedia.org/wiki/Work_stealing

برای جلوگیری از سربار نظرسنجی فیوچرها به صورت مکرر، اجرا کننده‌ها معمولاً از ای‌پی‌آی _waker_ پشتیبانی شده توسط فیوچرهای راست نیز بهره می‌برند.

#### بیدار کننده‌ها

ایده پشت ای‌پی‌آی waker این است که یک نوع خاص [`Waker`] به هر فراخوانی از `poll` ارسال می‌شود که در نوع [`Context`] بسته‌بندی شده است. این نوع `Waker` توسط اجرا کننده ایجاد می‌شود و می‌تواند توسط وظیفه ناهمزمان برای سیگنال دادن تکمیلِ (جزئی) آن استفاده شود. در نتیجه، اجرا کننده نیازی به فراخوانی `poll` در فیوچری که قبلاً `Poll::Pending` را نشان می‌داد، تا زمانی که توسط بیدار کننده مربوطه مطلع نشود، ندارد.

[`Context`]: https://doc.rust-lang.org/nightly/core/task/struct.Context.html

این مسئله به بهترین شکل با یک مثال کوچک نشان داده می‌شود:

```rust
async fn write_file() {
    async_write_file("foo.txt", "Hello").await;
}
```

این تابع به صورت ناهمزمان رشته "Hello" را در فایل `foo.txt` می‌نویسد. از آن‌جایی که نوشتن در هارد دیسک مدتی طول می‌کشد، اولین فراخوانی `poll` در فیوچر‌ احتمالاً `Poll::Pending` را برمی‌گرداند. با این حال، درایور هارد دیسک، `Waker` را که به فراخوانی `poll` ارسال می‌شود، ذخیره می‌کند و از آن برای اطلاع دادن به اجرا کننده هنگام نوشتن فایل روی دیسک استفاده می‌کند. به این ترتیب، اجرا کننده نیازی به هدر دادن زمان برای `poll` کردن دوباره فیوچر‌ قبل از دریافت اعلان بیدار کننده ندارد.

هنگامی که اجرا کننده خود را با پشتیبانی waker در بخش پیاده‌سازی این پست ایجاد می‌کنیم، نحوه عملکرد نوع `Waker` را با جزئیات خواهیم دید.

### چندوظیفه ای تعاونی؟

در ابتدای این پست در مورد چند وظیفه‌ای پیشگیرانه و مشارکتی صحبت کردیم. در حالی که چندوظیفه‌ای پیشگیرانه به سیستم‌عامل برای جابجایی اجباری بین وظایف در حال اجرا متکی است، چندوظیفه‌ای مشارکتی مستلزم آن است که وظایف به طور داوطلبانه از طریق یک عملیات _yield_ به طور منظم کنترل CPU را کنار بگذارند. مزیت بزرگ رویکرد مشارکتی این است که وظایف می‌توانند خودشان حالت خود را ذخیره کنند، که منجر به تعویض‌های زمینه (context switches) کارآمدتر می‌شود و امکان اشتراک‌گذاری پشته فراخوانی یکسان بین وظایف را ممکن می‌سازد.

ممکن است فوراً آشکار نباشد، اما فیوچرها و async/await یک پیاده‌سازی الگوی چندوظیفه‌ای مشارکتی است:

- هر فیوچر که به اجرا کننده اضافه می‌شود اساسا یک وظیفه تعاونی است.
- به جای استفاده از عملیات yield صریح، فیوچرها با برگرداندن `Poll::Pending` (یا `Poll::Ready` در پایان، کنترل هسته CPU را کنار می‌گذارند.
    - هیچ چیزی وجود ندارد که فیوچرها را مجبور به رها کردن CPU کند. اگر بخواهند، می‌توانند هرگز از `poll` برگرشت نداشته باشند، به عنوان مثال، با چرخیدن بی‌پایان در یک حلقه.
    - از آن‌جایی که هر فیوچر می‌تواند اجرای فیوچر دیگر را در اجرا کننده مسدود کند، باید به آن‌ها اعتماد کنیم که مخرب نباشند.
- فیوچرها تمام حالتی را که برای ادامه اجرا در فراخوانی بعدی `poll` نیاز دارند، به صورت داخلی ذخیره می‌کنند. با async/await، کامپایلر به طور خودکار تمام متغیرهای مورد نیاز را شناسایی کرده و آن‌ها را در ماشین حالت تولید شده ذخیره می‌کند.
    - فقط حداقل حالت مورد نیاز برای ادامه، ذخیره می‌شود.
    - از آن‌جایی که متد "poll" پس از بازگشت، پشته فراخوانی را رها می‌کند، می‌توان از همان پشته برای نظرسنجی سایر فیوچرها استفاده کرد.

می‌بینیم که فیوچرها و async/await با الگوی چندوظیفه‌ای تعاونی کاملاً مطابقت دارند، آن‌ها فقط از برخی اصطلاحات متفاوت استفاده می‌کنند. بنابراین، در ادامه، از اصطلاحات `وظیفه` و `فیوچر` به جای یکدیگر استفاده خواهیم کرد.

## پیاده‌سازی

اکنون که می‌دانیم چندوظیفه‌ای مشارکتی مبتنی بر فیوچر و async/await چگونه در راست کار می‌کند، زمان آن رسیده است که پشتیبانی از آن را به هسته خود اضافه کنیم. از آن‌جایی که ویژگی [`Future`] بخشی از کتابخانه `core` است و async/await یکی از ویژگی‌های خود زبان است، برای استفاده از آن در هسته `#![no_std]` نیازی به انجام کار خاصی نیست. تنها شرط لازم این است که حداقل از nightly نسخه `2020-03-25` به بعد استفاده کنیم زیرا async/await قبلاً با `no_std` سازگار نبود.

با داشتن یک نسخه مناسب از nightly، می‌توانیم از async/await در `main.rs` استفاده کنیم:

```rust
// in src/main.rs

async fn async_number() -> u32 {
    42
}

async fn example_task() {
    let number = async_number().await;
    println!("async number: {}", number);
}
```

تابع `async_number` یک `async fn` است، بنابراین کامپایلر آن را به یک ماشین حالت تبدیل می‌کند که `Future` را پیاده‌سازی می‌کند. از آن‌جایی که تابع فقط `42` را برمی گرداند، فیوچر حاصل مستقیماً `Poll::Ready(42)` را در اولین فراخوانی `poll` برمی‌گرداند. مانند `async_number`، تابع `example_task` نیز یک `async fn` است. منتظر عددی است که توسط `async_number` برگردانده شده است و سپس آن را با استفاده از ماکرو `println` چاپ می‌کند.

برای اجرای فیوچر برگردانده شده توسط `example_task`، باید `poll` را روی آن فراخوانی کنیم تا زمانی که با برگرداندن `Poll::Ready`، سیگنال تکمیل آن را نشان دهد. برای این کار باید یک نوع اجرا کننده ساده ایجاد کنیم.

### وظیفه

قبل از شروع پیاده‌سازی اجرا کننده، یک ماژول `task` جدید با نوع `Task` ایجاد می‌کنیم:

```rust
// in src/lib.rs

pub mod task;
```

```rust
// in src/task/mod.rs

use core::{future::Future, pin::Pin};
use alloc::boxed::Box;

pub struct Task {
    future: Pin<Box<dyn Future<Output = ()>>>,
}
```

ساختمان‌ `Task` یک بسته‌بندی نوع جدید در اطراف یک فیوچر پین شده، تخصیص داده شده و به صورت پویا با نوع خالی `()` به عنوان خروجی است. بیایید آن را با جزئیات مرور کنیم:

- ما نیاز داریم که فیوچر مرتبط با یک وظیفه، `()` را برگرداند. این بدان معناست که وظیفه‌ها هیچ نتیجه‌ای ندارند، آن‌ها فقط برای اثر جانبی آن اجرا می‌شوند. به عنوان مثال، تابع `example_task` که در بالا تعریف کردیم، مقدار بازگشتی ندارد، اما چیزی را به عنوان یک اثر جانبی روی صفحه چاپ می‌کند.
- کلمه کلیدی `dyn` نشان می‌دهد که ما یک [_trait object_] را در `Box` ذخیره می‌کنیم. این بدان معناست که متدهای فیوچر [_دینامیکی ارسال شده‌اند_]، که امکان ذخیره انواع مختلف فیوچر را در نوع `Task` فراهم می‌کند. این مهم است زیرا هر `async fn` نوع خاص خود را دارد و ما می‌خواهیم بتوانیم چندین وظیفه مختلف ایجاد کنیم.
- همانطور که در [بخش در مورد پین کردن] آموختیم، نوع `Pin<Box>` با قرار دادن یک مقدار روی هیپ و جلوگیری از ایجاد ارجاعات `&mut` به آن، تضمین می‌کند که نمی‌توان یک مقدار را در حافظه جابجا کرد. این مهم است زیرا فیوچرهایی که توسط async/await تولید می‌شوند ممکن است خود ارجاعی باشند، یعنی حاوی اشاره‌گرهایی به خود باشند که در صورت جابجایی فیوچر باطل می‌شوند.

[_trait object_]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html
[_dynamically dispatched_]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch
[section about pinning]: #pinning

برای اجازه دادن به ایجاد ساختمان‌های جدید `Task` از فیوچر، یک تابع `new` ایجاد می‌کنیم:

```rust
// in src/task/mod.rs

impl Task {
    pub fn new(future: impl Future<Output = ()> + 'static) -> Task {
        Task {
            future: Box::pin(future),
        }
    }
}
```

این تابع یک فیوچر دلخواه با نوع خروجی `()` می‌گیرد و آن را از طریق تابع [`Box::pin`] در حافظه پین می‌کند. سپس فیوچر درون Box را در ساختمان‌ `Task` بسته‌بندی کرده و آن را برمی‌گرداند. طول عمر `'static` در اینجا مورد نیاز است زیرا `Task` برگشتی می‌تواند برای یک زمان دلخواه زنده بماند، بنابراین فیوچر باید برای آن زمان نیز معتبر باشد.

ما همچنین یک متد `poll` اضافه می‌کنیم تا به اجرا کننده اجازه دهیم فیوچر ذخیره شده را نظرسنجی کند:

```rust
// in src/task/mod.rs

use core::task::{Context, Poll};

impl Task {
    fn poll(&mut self, context: &mut Context) -> Poll<()> {
        self.future.as_mut().poll(context)
    }
}
```

از آن‌جایی که انتظار می‌رود متد [`poll`] از صفت `Future` در نوع `Pin<&mut T>` فراخوانی شود، در ابتدا برای تبدیل فیلد `self.future` از نوع `Pin<Box<T>>`، از متد [`Pin::as_mut`] استفاده می‌کنیم. سپس `poll` را در فیلد `self.future` تبدیل شده فراخوانی می‌کنیم و نتیجه را برمی‌گردانیم. از آن‌جایی که متد `Task::poll` باید فقط توسط اجرا کننده که به زودی ایجاد می‌کنیم فراخوانی شود، تابع را در ماژول `task` خصوصی نگه می‌داریم.

### یک اجرا کننده ساده

از آن جایی که اجرا کننده‌ها می‌توانند بسیار پیچیده باشند، ما عمداً با ایجاد یک اجرا کننده‌ بسیار ابتدایی شروع می‌کنیم تا در ادامه یک اجرا کننده‌ با ویژگی‌های بیشتر را پیاده‌سازی کنیم. برای این، ابتدا یک زیر ماژول جدید `task::simple_executor` ایجاد می‌کنیم:

```rust
// in src/task/mod.rs

pub mod simple_executor;
```

```rust
// in src/task/simple_executor.rs

use super::Task;
use alloc::collections::VecDeque;

pub struct SimpleExecutor {
    task_queue: VecDeque<Task>,
}

impl SimpleExecutor {
    pub fn new() -> SimpleExecutor {
        SimpleExecutor {
            task_queue: VecDeque::new(),
        }
    }

    pub fn spawn(&mut self, task: Task) {
        self.task_queue.push_back(task)
    }
}
```

این ساختمان‌ حاوی یک فیلد `task_queue` از نوع [`VecDeque`] است، که اساساً یک وکتور است که امکان پوش (push) و پاپ (pop) کردن در هر دو طرف را فراهم می‌کند. ایده استفاده از این نوع این است که ما وظایف جدید را از طریق متد `spawn` در انتها وارد می‌کنیم و وظیفه بعدی را برای اجرا از جلو پاپ می‌کنیم. به این ترتیب، یک [صف FIFO] ساده (_"خروج به ترتیب ورود"_) دریافت می‌کنیم.

[`VecDeque`]: https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html
[صف FIFO]: https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)

#### بیدار کننده ساختگی

برای فراخوانی متد `poll`، باید یک نوع [`Context`] ایجاد کنیم که نوع [`Waker`] را بسته‌بندی می‌کند. برای شروع ساده، ابتدا یک بیدار کننده ساختگی ایجاد می‌کنیم که هیچ کاری انجام نمی‌دهد. برای این، یک نمونه [`RawWaker`] ایجاد می‌کنیم که پیاده‌سازی‌ متدهای مختلف `Waker` را تعریف می‌کند، و سپس از تابع [`Waker::from_raw`] برای تبدیل آن به `Waker` استفاده می‌کنیم:

[`RawWaker`]: https://doc.rust-lang.org/stable/core/task/struct.RawWaker.html
[`Waker::from_raw`]: https://doc.rust-lang.org/stable/core/task/struct.Waker.html#method.from_raw

```rust
// in src/task/simple_executor.rs

use core::task::{Waker, RawWaker};

fn dummy_raw_waker() -> RawWaker {
    todo!();
}

fn dummy_waker() -> Waker {
    unsafe { Waker::from_raw(dummy_raw_waker()) }
}
```

تابع `from_raw` ناامن است زیرا اگر برنامه‌نویس الزامات مستند `RawWaker` را رعایت نکند، ممکن است رفتاری تعریف نشده رخ دهد. قبل از اینکه به پیاده‌سازی تابع `dummy_raw_waker` نگاه کنیم، ابتدا سعی می‌کنیم بفهمیم نوع `RawWaker` چگونه کار می‌کند.

##### `RawWaker`

نوع [`RawWaker`] از برنامه‌نویس می‌خواهد که به صراحت یک [_جدول متد مجازی_] (_vtable_) تعریف کند که توابعی را مشخص می‌کند که باید هنگام شبیه‌سازی (cloned)، بیدار شدن یا حذف شدن `RawWaker` فراخوانی شوند. چیدمان این vtable با نوع [`RawWakerVTable`] تعریف می‌شود. هر تابع یک آرگومان `*const ()` دریافت می‌کند که اساساً اشاره‌گر _type-erased_ `&self` به برخی ساختمان‌ها است، به عنوان مثال، اختصاص داده شده بر روی هیپ. دلیل استفاده از اشاره‌گر `*const ()` به جای مرجع مناسب این است که نوع `RawWaker` باید غیرعمومی باشد اما همچنان از انواع دلخواه پشتیبانی می‌کند. مقدار اشاره‌گر که به توابع ارسال می‌شود، اشاره‌گر `data` است که به [`RawWaker::new`] داده می‌شود.

[_جدول متد مجازی_]: https://en.wikipedia.org/wiki/Virtual_method_table
[`RawWakerVTable`]: https://doc.rust-lang.org/stable/core/task/struct.RawWakerVTable.html
[`RawWaker::new`]: https://doc.rust-lang.org/stable/core/task/struct.RawWaker.html#method.new

به طور معمول، `RawWaker` برای برخی از ساختمان‌های تخصیص یافته هیپ ایجاد می‌شود که در نوع [`Box`] یا [`Arc`] بسته‌بندی شده است. برای چنین انواعی، متدهایی مانند [`Box::into_raw`] را می توان برای تبدیل `Box<T>` به اشاره‌گر `*const T` استفاده کرد. سپس این اشاره‌گر را می‌توان به قالب یک اشاره‌گر `*const ()` ناشناس درآورد و به `RawWaker::new` فرستاد. از آن‌جایی که هر تابع vtable همان `*const ()` را به عنوان آرگومان دریافت می‌کند، توابع می‌توانند با خیال راحت اشاره‌گر را به `Box<T>` یا `&T` برگردانند تا روی آن کار کنند. همانطور که می‌توانید تصور کنید، این فرآیند بسیار خطرناک است و به راحتی می‌تواند در صورت اشتباه کردن منجر به رفتار نامشخص شود. به همین دلیل، ایجاد دستی `RawWaker` توصیه نمی‌شود مگر در موارد ضروری.

[`Box`]: https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html
[`Arc`]: https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html
[`Box::into_raw`]: https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html#method.into_raw

##### یک `RawWaker` ساختگی

در حالی که ایجاد دستی `RawWaker` توصیه نمی‌شود، در حال حاضر هیچ راه دیگری برای ایجاد یک `Waker` ساختگی که هیچ کاری انجام نمی‌دهد وجود ندارد. خوشبختانه، این واقعیت که ما نمی‌خواهیم هیچ کاری انجام دهیم، اجرای تابع `dummy_raw_waker` را نسبتاً ایمن می‌کند:

```rust
// in src/task/simple_executor.rs

use core::task::RawWakerVTable;

fn dummy_raw_waker() -> RawWaker {
    fn no_op(_: *const ()) {}
    fn clone(_: *const ()) -> RawWaker {
        dummy_raw_waker()
    }

    let vtable = &RawWakerVTable::new(clone, no_op, no_op, no_op);
    RawWaker::new(0 as *const (), vtable)
}
```

ابتدا دو تابع داخلی به نام‌های `no_op` و `clone` تعریف می‌کنیم. تابع `no_op` یک اشاره‌گر `*const ()` می‌گیرد و هیچ کاری انجام نمی‌دهد. تابع `clone` همچنین یک اشاره‌گر `*const ()` می‌گیرد و با فراخوانی مجدد `dummy_raw_waker` یک `RawWaker` جدید برمی‌گرداند. از این دو تابع برای ایجاد یک `RawWakerVTable` استفاده می‌کنیم: تابع `clone` برای عملیات شبیه‌سازی و تابع `no_op` برای همه عملیات‌های دیگر استفاده می‌شود. از آن‌جایی که `RawWaker` هیچ کاری انجام نمی‌دهد، مهم نیست که `RawWaker` جدید را به جای شبیه‌سازی، صرفاً از `clone` برگردانیم.

پس از ایجاد `vtable`، از تابع [`RawWaker::new`] برای ایجاد `RawWaker` استفاده می‌کنیم. دادن `*const ()` به تابع مهم نیست زیرا هیچ یک از توابع vtable از آن استفاده نمی‌کند. به همین دلیل، ما به سادگی یک اشاره‌گر تهی را ارسال می‌کنیم.

#### یک متد `run`

اکنون راهی برای ایجاد یک نمونه `Waker` داریم، می‌توانیم از آن برای پیاده‌سازی متد `run` در اجرا کننده خود استفاده کنیم. ساده‌ترین متد `run` این است که به طور مکرر همه وظایف در صف را در یک حلقه نظرسنجی کنید تا زمانی که همه وظیفه‌ها انجام شود. این خیلی کارآمد نیست زیرا از اعلان‌های نوع `Waker` استفاده نمی‌کند، اما راهی آسان برای اجرای کارها است:

```rust
// in src/task/simple_executor.rs

use core::task::{Context, Poll};

impl SimpleExecutor {
    pub fn run(&mut self) {
        while let Some(mut task) = self.task_queue.pop_front() {
            let waker = dummy_waker();
            let mut context = Context::from_waker(&waker);
            match task.poll(&mut context) {
                Poll::Ready(()) => {} // task done
                Poll::Pending => self.task_queue.push_back(task),
            }
        }
    }
}
```

این تابع از حلقه `while let` برای رسیدگی به تمام وظایف موجود در `task_queue` استفاده می‌کند. برای هر وظیفه، ابتدا یک نوع `Context` با قرار دادن یک نمونه `Waker` که توسط تابع `dummy_waker` ما برگردانده شده است ایجاد می‌کند. سپس متد `Task::poll` را با این `context` فراخوانی می‌کند. اگر متد `poll` مقدار `Poll::Ready` را برگرداند، وظیفه به اتمام رسیده و می‌توانیم وظیفه بعدی را ادامه دهیم. اگر وظیفه همچنان `Poll::Pending` است، آن را دوباره به پشت صف اضافه می‌کنیم تا در اجرای بعدی حلقه دوباره نظرسنجی شود.

#### تست کردن

با نوع `SimpleExecutor`، اکنون می‌توانیم وظیفه‌ای را که توسط تابع `example_task` برگردانده شده در `main.rs` اجرا کنیم:

```rust
// in src/main.rs

use blog_os::task::{Task, simple_executor::SimpleExecutor};

fn kernel_main(boot_info: &'static BootInfo) -> ! {
    // […] initialization routines, including `init_heap`

    let mut executor = SimpleExecutor::new();
    executor.spawn(Task::new(example_task()));
    executor.run();

    // […] test_main, "it did not crash" message, hlt_loop
}


// Below is the example_task function again so that you don't have to scroll up

async fn async_number() -> u32 {
    42
}

async fn example_task() {
    let number = async_number().await;
    println!("async number: {}", number);
}
```

وقتی آن را اجرا می‌کنیم، می‌بینیم که پیام مورد انتظار _"async number: 42"_ روی صفحه نمایش داده می‌شود:

![QEMU printing "Hello World", "async number: 42", and "It did not crash!"](qemu-simple-executor.png)

بیایید مراحل مختلفی را که برای این مثال اتفاق می‌افتد، خلاصه‌نویسی کنیم:

- ابتدا یک نمونه جدید از نوع `SimpleExecutor` با یک `task_queue` خالی ایجاد می‌شود.
- در مرحله بعد، تابع `example_task` ناهمزمان را فراخوانی می‌کنیم که یک فیوچر را برمی‌گرداند. این فیوچر را در نوع `Task` بسته‌بندی می‌کنیم، که آن را به هیپ منتقل کرده و آن را پین می‌کند، و سپس وظیفه را از طریق متد `spawn` به `task_queue` اجرا کننده اضافه می‌کنیم.
- سپس متد `run` را برای شروعِ اجرای تک  وظیفه موجود در صف فراخوانی می‌کنیم. این شامل:
    - پاپ کردن وظیفه از جلوی `task_queue`.
    - ایجاد یک `RawWaker` برای وظیفه، تبدیل آن به یک نمونه [`Waker`]، و سپس ایجاد یک نمونه [`Context`] از آن.
    - فراخوانی متد [`poll`] در فیوچر مربوط به وظیفه، با استفاده از `Context` که ایجاد کردیم.
    - از آن‌جایی که `example_task` منتظر چیزی نمی‌ماند، می تواند مستقیماً تا پایان خود در اولین فراخوانی `poll` اجرا شود. اینجاست که خط _"async number: 42"_ چاپ می‌شود.
    - از آن‌جایی که `example_task` مستقیماً `Poll::Ready` را برمی‌گرداند، به صف وظیفه اضافه نمی‌شود.
- متد `run` پس از خالی شدن `task_queue` برمی‌گردد. اجرای تابع `kernel_main` ادامه می‌یابد و پیام _"It did not crash!"_ چاپ می‌شود.

### ورودی صفحه‌کلید غیرهمگام

اجرا کننده ساده ما از اعلان‌های `Waker` استفاده نمی‌کند و به سادگی همه وظیفه‌ها را تا زمانی که انجام نشوند، درون حلقه پیمایش می‌کند. این مشکلی برای مثال ما نبود، زیرا `example_task` می‌تواند مستقیماً در اولین فراخوانی `poll` اجرا شود. برای دیدن مزایای عملکرد یک پیاده‌سازی `Waker` مناسب، ابتدا باید وظیفه‌ای ایجاد کنیم که واقعاً ناهمزمان باشد، یعنی وظیفه‌ای که احتمالاً در اولین فراخوانی `poll` مقدار `Poll::Pending` را برمی‌گرداند.

هم اکنون یک نوعی از ناهمزمانی در سیستم خود داریم که می‌توانیم برای این وظیفه‌ از آن استفاده کنیم: وقفه‌های سخت افزاری. همانطور که در پست [_وقفه‌ها_] آموختیم، وقفه‌های سخت‌افزاری می‌توانند در زمان‌های دلخواه رخ دهند که توسط برخی از دستگاه‌های خارجی تعیین می‌شود. به عنوان مثال، یک تایمر سخت‌افزاری پس از سپری شدن مدتی معین، یک وقفه به CPU ارسال می‌کند. هنگامی که CPU یک وقفه دریافت می‌کند، بلافاصله کنترل را به تابع کنترل کننده مربوطه که در جدول توصیف کننده وقفه (IDT) تعریف شده است منتقل می‌کند.

[_وقفه‌ها_]: @/edition-2/posts/07-hardware-interrupts/index.md

در ادامه یک وظیفه ناهمزمان بر اساس وقفه صفحه‌کلید ایجاد می‌کنیم. وقفه صفحه‌کلید کاندید خوبی برای این کار است زیرا هم غیر قطعی (non-deterministic) و هم تأخیر در آن بسیار بحرانی (latency-critical) است. Non-deterministic به این معنی است که هیچ راهی برای پیش‌بینی زمان فشار دادن کلید بعدی وجود ندارد زیرا کاملاً به کاربر وابسته است. Latency-critical به این معنی است که ما می‌خواهیم ورودی صفحه‌کلید را به موقع مدیریت کنیم، در غیر این صورت کاربر یک تاخیر (lag) احساس می‌کند. برای پشتیبانی از چنین وظیفه‌ای به روشی کارآمد، ضروری است که اجرا کننده از اعلان‌های `Waker` پشتیبانی مناسبی داشته باشد.

#### صف اسکن کد

در حال حاضر، ما ورودی صفحه‌کلید را مستقیماً در کنترل‌کننده وقفه، کنترل می‌کنیم. این ایده خوبی برای بلندمدت نیست زیرا کنترل‌کننده وقفه باید تا حد امکان کوتاه باشند زیرا ممکن است باعث وقفه در کار مهم شوند. در عوض، کنترل‌کننده‌های وقفه فقط باید حداقل مقدار کار لازم را انجام دهند (مثلاً خواندن اسکن کد صفحه‌کلید) و بقیه کار (مثلاً تفسیر اسکن کد) را به یک وظیفه پس‌زمینه‌ای بسپارند.

یک الگوی رایج برای واگذاری کار به یک وظیفه پس‌زمینه‌ای، ایجاد نوعی صف است. کنترل‌کننده وقفه واحدهای کار را به صف پوش می‌کند و وظیفه پس‌زمینه‌‌ای کار را در صف اداره می‌کند. در مورد وقفه صفحه‌کلید ما اعمال می‌شود، یعنی کنترل‌کننده وقفه فقط اسکن کد را از صفحه‌کلید می‌خواند، آن را به صف پوش می‌کند و سپس برمی‌گردد. وظیفه صفحه‌کلید در انتهای دیگر صف قرار می‌گیرد و هر کد اسکنی را که به آن پوش می‌شود تفسیر و مدیریت می‌کند:

![Scancode queue with 8 slots on the top. Keyboard interrupt handler on the bottom left with a "push scancode" arrow to the left of the queue. Keyboard task on the bottom right with a "pop scancode" queue coming from the right side of the queue.](scancode-queue.svg)

یک پیاده‌سازی ساده از آن صف می‌تواند یک [`VecDeque`] محافظت شده توسط mutex باشد. با این حال، استفاده از mutexها در کنترل‌کننده‌های وقفه ایده خوبی نیست زیرا می‌تواند به راحتی منجر به بن‌بست (deadlock) شود. به عنوان مثال، هنگامی که کاربر کلیدی را فشار می‌دهد در حالی که وظیفه صفحه‌کلید صف را قفل کرده است، کنترل‌کننده وقفه سعی می‌کند دوباره قفل را بدست آورد و به‌طور نامحدود هنگ می‌کند. مشکل دیگر این رویکرد این است که `VecDeque` به طور خودکار ظرفیت خود را با انجام یک تخصیص هیپ جدید در هنگام پر شدن افزایش می‌دهد. این می‌تواند دوباره به بن‌بست منجر شود زیرا تخصیص‌دهنده ما نیز از یک mutex به صورت داخلی استفاده می‌کند. مشکلات دیگر این است که تخصیص هیپ ممکن است با شکست مواجه شود یا حین تکه‌تکه شدن (fragmentation) هیپ، زمان قابل توجهی صرف شود.

برای جلوگیری از این مشکلات، ما به یک پیاده‌سازی صف نیاز داریم که به mutexها یا تخصیص برای عملیات `push` آن نیاز نداشته باشد. چنین صف‌هایی را می‌توان با استفاده از [atomic operations] بدون قفل برای پوش و پاپ کردن عناصر پیاده‌سازی کرد. به این ترتیب، امکان ایجاد عملیات `push` و `pop` وجود دارد که فقط به مرجع `&self` نیاز دارند و بنابراین بدون mutex قابل استفاده هستند. برای جلوگیری از تخصیص در `push`، صف می‌تواند توسط یک بافر با اندازه ثابت از قبل تخصیص داده شده پشتیبانی شود. در حالی که این باعث می‌شود که صف _bounded_ شود (یعنی دارای حداکثر طول باشد)، اغلب می‌توان در عمل کران‌های بالایی منطقی برای طول صف تعریف کرد تا مشکل بزرگی ایجاد نکند.

[atomic operations]: https://doc.rust-lang.org/core/sync/atomic/index.html

##### کریت `crossbeam`

پیاده‌سازی چنین صفی به روشی صحیح و کارآمد بسیار دشوار است، بنابراین توصیه می‌کنم به پیاده‌سازی‌های موجود و آزمایش شده پایبند باشید. یکی از پروژه‌های محبوب راست که انواع مختلفِ بدون mutex را برای برنامه‌نویسی همزمان پیاده‌سازی می‌کند، [`crossbeam`] است. یک نوع به نام [`ArrayQueue`] ارائه می‌کند که دقیقاً همان چیزی است که در این مورد نیاز داریم. و ما خوش شانسیم: این نوع کاملاً با کریت‌های `no_std` با پشتیبانی تخصیص سازگار است.

[`crossbeam`]: https://github.com/crossbeam-rs/crossbeam
[`ArrayQueue`]: https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html

برای استفاده از این نوع، باید یک وابستگی به کریت `crossbeam-queue` اضافه کنیم:

```toml
# in Cargo.toml

[dependencies.crossbeam-queue]
version = "0.2.1"
default-features = false
features = ["alloc"]
```

به طور پیش‌فرض، این کریت به کتابخانه استاندارد بستگی دارد. برای اینکه `no_std` سازگار باشد، باید ویژگی‌های پیش‌فرض آن را غیرفعال کنیم و به جای آن ویژگی `alloc` را فعال کنیم. <span class="gray">(توجه داشته باشید که بسته به کریت اصلی `crossbeam` در اینجا کار نمی‌کند زیرا یک export از ماژول `queue` برای `no_std` وجود ندارد. من یک [pull request](https://github.com/crossbeam-rs/crossbeam/pull/480) برای رفع این مشکل ارسال کردم، اما هنوز در crates.io منتشر نشده است.)</span>

##### پیاده‌سازی صف

با استفاده از نوع `ArrayQueue`، اکنون می‌توانیم یک صف اسکن کد سراسری در یک ماژول `task::keyboard` جدید ایجاد کنیم:

```rust
// in src/task/mod.rs

pub mod keyboard;
```

```rust
// in src/task/keyboard.rs

use conquer_once::spin::OnceCell;
use crossbeam_queue::ArrayQueue;

static SCANCODE_QUEUE: OnceCell<ArrayQueue<u8>> = OnceCell::uninit();
```

از آن‌جایی که [`ArrayQueue::new`] یک تخصیص هیپ را انجام می‌دهد، که در زمان کامپایل امکان‌پذیر نیست ([هنوز][const-heap-alloc])، نمی‌توانیم متغیر استاتیک را مستقیماً مقداردهی اولیه کنیم. در عوض، ما از نوع [`OnceCell`] کریت [`conquer_once`] استفاده می‌کنیم، که امکان مقداردهی اولیه یکباره ایمنِ مقادیر استاتیک را فراهم می‌کند. برای شامل کردن کریت، باید آن را به عنوان یک وابستگی در `Cargo.toml` خود اضافه کنیم:

[`ArrayQueue::new`]: https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html#method.new
[const-heap-alloc]: https://github.com/rust-lang/const-eval/issues/20
[`OnceCell`]: https://docs.rs/conquer-once/0.2.0/conquer_once/raw/struct.OnceCell.html
[`conquer_once`]: https://docs.rs/conquer-once/0.2.0/conquer_once/index.html

```toml
# in Cargo.toml

[dependencies.conquer-once]
version = "0.2.0"
default-features = false
```

به جای [`OnceCell`] اولیه، می‌توانیم از ماکرو [`lazy_static`] نیز در اینجا استفاده کنیم. با این حال، نوع `OnceCell` این مزیت را دارد که می‌توانیم اطمینان حاصل کنیم که مقداردهی اولیه در کنترل‌کننده وقفه اتفاق نمی‌افتد، بنابراین از انجام تخصیص هیپ توسط کنترل‌کننده وقفه جلوگیری می‌شود.

[`lazy_static`]: https://docs.rs/lazy_static/1.4.0/lazy_static/index.html

#### پر کردن صف

برای پر کردن صف اسکن کد، یک تابع `add_scancode` جدید ایجاد می‌کنیم که آن را از کنترل‌کننده وقفه فراخوانی می‌کنیم:

```rust
// in src/task/keyboard.rs

use crate::println;

/// Called by the keyboard interrupt handler
///
/// Must not block or allocate.
pub(crate) fn add_scancode(scancode: u8) {
    if let Ok(queue) = SCANCODE_QUEUE.try_get() {
        if let Err(_) = queue.push(scancode) {
            println!("WARNING: scancode queue full; dropping keyboard input");
        }
    } else {
        println!("WARNING: scancode queue uninitialized");
    }
}
```

ما از [`OnceCell::try_get`] برای دریافت ارجاع به صف مقداردهی شده استفاده می‌کنیم. اگر صف هنوز مقداردهی اولیه نشده باشد، اسکن کدِ صفحه کلید را نادیده می‌گیریم و یک هشدار چاپ می‌کنیم. مهم است که سعی نکنیم صف را در این تابع مقداردهی کنیم زیرا توسط کنترل‌کننده وقفه فراخوانی می‌شود که نباید تخصیص هیپ را انجام دهد. از آن‌جایی که این تابع نباید از `main.rs` ما قابل فراخوانی باشد، از قابلیت مشاهده `pub(crate)` استفاده می‌کنیم تا آن را فقط برای `lib.rs` خود در دسترس قرار دهیم.

[`OnceCell::try_get`]: https://docs.rs/conquer-once/0.2.0/conquer_once/raw/struct.OnceCell.html#method.try_get

این واقعیت که متد [`ArrayQueue::push`] فقط به یک مرجع "&self" نیاز دارد، فراخوانی متد را در صف استاتیک بسیار ساده می‌کند. نوع `ArrayQueue` تمام همگام‌سازی‌های لازم را خود انجام می‌دهد، بنابراین ما در اینجا نیازی به بسته‌بندی mutex نداریم. در صورت پر شدن صف، یک هشدار نیز چاپ می‌کنیم.

[`ArrayQueue::push`]: https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html#method.push

برای فراخوانی تابع `add_scancode` در وقفه‌های صفحه‌کلید، تابع `keyboard_interrupt_handler` را در ماژول `interrupts` به‌روزرسانی می‌کنیم:

```rust
// in src/interrupts.rs

extern "x86-interrupt" fn keyboard_interrupt_handler(
    _stack_frame: InterruptStackFrame
) {
    use x86_64::instructions::port::Port;

    let mut port = Port::new(0x60);
    let scancode: u8 = unsafe { port.read() };
    crate::task::keyboard::add_scancode(scancode); // new

    unsafe {
        PICS.lock()
            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
    }
}
```

ما همه کدهای کنترل صفحه‌کلید را از این تابع حذف کردیم و به جای آن یک فراخوانی به تابع `add_scancode` اضافه کردیم. بقیه تابع مانند قبل باقی می‌ماند.

همانطور که انتظار می‌رفت، وقتی پروژه خود را با استفاده از `cargo run` اکنون اجرا می‌کنیم، فشردن کلیدها دیگر روی صفحه چاپ نمی‌شوند. در عوض، ما هشداری را می‌بینیم که صف اسکن کد برای هر بار زدن کلید، مقدار دهی اولیه نمی‌شود.

#### جریان اسکن کد

برای مقداردهی اولیه `SCANCODE_QUEUE` و خواندن کدهای اسکن از صف به روش ناهمزمان، یک نوع `ScancodeStream` جدید ایجاد می‌کنیم:

```rust
// in src/task/keyboard.rs

pub struct ScancodeStream {
    _private: (),
}

impl ScancodeStream {
    pub fn new() -> Self {
        SCANCODE_QUEUE.try_init_once(|| ArrayQueue::new(100))
            .expect("ScancodeStream::new should only be called once");
        ScancodeStream { _private: () }
    }
}
```

هدف از فیلد `_private` جلوگیری از ساخت ساختمان‌ در خارج از ماژول است. این باعث می‌شود که تابع "new" تنها راه برای ساخت نوع باشد. در تابع، ابتدا سعی می‌کنیم استاتیک `SCANCODE_QUEUE` را مقداردهی اولیه کنیم. اگر از قبل مقداردهی اولیه شده باشد جهت این‌که مطمئن شویم تنها یک نمونه `ScancodeStream` می‌تواند ایجاد شود، پنیک می‌کنیم.

برای در دسترس قرار دادن اسکن کدها برای وظیفه‌های ناهمزمان، گام بعدی پیاده‌سازی متد `poll` است که سعی می‌کند اسکن کد بعدی را از صف خارج کند. در حالی که به نظر می‌رسد باید صفت [`Future`] را برای نوع خود پیاده‌سازی کنیم، این در اینجا کاملاً مناسب نیست. مشکل این است که صفت `Future` فقط روی یک مقدار ناهمزمان انتزاع می‌کند و انتظار دارد که متد `poll` پس از برگرداندن `Poll::Ready` دوباره فراخوانی نشود. با این حال، صف اسکن کد ما حاوی مقادیر ناهمزمان متعددی است، به طوری که ادامه نظرسنجی آن مشکلی ندارد.

##### صفت `Stream`

از آن‌جایی که انواعی که چندین مقدار ناهمزمان را حاصل می‌شوند رایج هستند، کریت [`futures`] یک انتزاع مفید برای چنین انواعی ارائه می‌کند: صفت [`Stream`]. این صفت به این صورت تعریف می‌شود:

[`Stream`]: https://rust-lang.github.io/async-book/05_streams/01_chapter.html

```rust
pub trait Stream {
    type Item;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context)
        -> Poll<Option<Self::Item>>;
}
```

این تعریف کاملاً شبیه صفت [`Future`] است، با تفاوت‌های زیر:

- نوع مرتبط بجای `Output` با `Item` نامگذاری شده است.
- به جای متد `poll` که `Poll<Self::Item>` را برمی‌گرداند، صفت `Stream` یک متد `poll_next` را تعریف می‌کند که یک `Poll<Option<Self::Item>>` را برمی‌گرداند (به موارد اضافی "Option" توجه کنید).

یک تفاوت معنایی نیز وجود دارد: `poll_next` را می‌توان مکرراً فراخوانی کرد، تا زمانی که `Poll::Ready(None)` را برگرداند تا نشان دهد که جریان به پایان رسیده است. از این نظر، متد شبیه به متد [`Iterator::next`] است که بعد از آخرین مقدار نیز "None" را برمی‌گرداند.

[`Iterator::next`]: https://doc.rust-lang.org/stable/core/iter/trait.Iterator.html#tymethod.next

##### پیاده‌سازی `Stream`

بیایید صفت `Stream` را برای `ScancodeStream` خود پیاده‌سازی کنیم تا مقادیر `SCANCODE_QUEUE` را به صورت ناهمزمان ارائه کنیم. برای این کار، ابتدا باید یک وابستگی به کریت "futures-util" اضافه کنیم که شامل نوع `Stream` است:

```toml
# in Cargo.toml

[dependencies.futures-util]
version = "0.3.4"
default-features = false
features = ["alloc"]
```

ما ویژگی‌های پیش‌فرض را غیرفعال می‌کنیم تا کریت `no_std` سازگار باشد و ویژگی `alloc` را فعال می‌کنیم تا انواع مبتنی بر تخصیص خود را در دسترس قرار دهد (بعداً به آن نیاز خواهیم داشت). <span class="gray">(توجه داشته باشید که ما همچنین می‌توانیم یک وابستگی به کریت اصلی `futures` اضافه کنیم، که کریت `futures-util` را دوباره صادر (export) می‌کند، اما این منجر به تعداد بیشتر وابستگی‌ها و زمان‌های کامپایل طولانی‌تر می‌شود.)</span>

اکنون می‌توانیم صفت `Stream` را وارد (import) و پیاده‌سازی کنیم:

```rust
// in src/task/keyboard.rs

use core::{pin::Pin, task::{Poll, Context}};
use futures_util::stream::Stream;

impl Stream for ScancodeStream {
    type Item = u8;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Option<u8>> {
        let queue = SCANCODE_QUEUE.try_get().expect("not initialized");
        match queue.pop() {
            Ok(scancode) => Poll::Ready(Some(scancode)),
            Err(crossbeam_queue::PopError) => Poll::Pending,
        }
    }
}
```

ابتدا از متد [`OnceCell::try_get`] برای دریافت مرجع به صف اسکن کد مقداردهی اولیه شده استفاده می‌کنیم. این هرگز نباید شکست بخورد زیرا ما صف را در تابع `new` مقداردهی اولیه می‌کنیم، بنابراین می‌توانیم با خیال راحت از متد `expect` برای پنیک کردن استفاده کنیم اگر مقداردهی اولیه نشده باشد. در مرحله بعد، از متد [`ArrayQueue::pop`] استفاده می‌کنیم تا عنصر بعدی را از صف دریافت کنیم. اگر موفق شد، اسکن کد بسته‌بندی شده در `Poll::Ready(Some(…))` را برمی‌گردانیم. اگر ناموفق بود به این معنی است که صف خالی است. در این صورت، `Poll::Pending` را برمی‌گردانیم.

[`ArrayQueue::pop`]: https://docs.rs/crossbeam/0.7.3/crossbeam/queue/struct.ArrayQueue.html#method.pop

#### پشتیبانی بیدار کننده

مانند متد `Futures::poll`، متد `Stream::poll_next` مستلزم آن است که وظیفه ناهمزمان پس از بازگشت `Poll::Pending` به اجرا کننده اطلاع دهد. به این ترتیب اجرا کننده نیازی به نظرسنجی مجدد همان وظیفه تا زمانی که به آن اطلاع داده شود ندارد، که به این صورت سربار عملکرد وظایف در حال انتظار را بسیار کاهش می‌دهد.

برای ارسال این اعلان، وظیفه باید [`Waker`] را از مرجع ارسال شده [`Context`] استخراج کرده و در جایی ذخیره کند. هنگامی که وظیفه آماده شد، باید متد [`wake`] را در `Waker` ذخیره شده فراخوانی کند تا به اجرا کننده اطلاع دهد که کار باید دوباره نظرسنجی شود.

##### AtomicWaker

برای پیاده‌سازی اعلان `Waker` برای `ScancodeStream`، به مکانی نیاز داریم که بتوانیم `Waker` را بین فراخوانی‌های نظرسنجی ذخیره کنیم. ما نمی‌توانیم آن را به‌عنوان یک فیلد در خود `ScancodeStream` ذخیره کنیم، زیرا باید از تابع `add_scancode` در دسترس باشد. راه حل برای این کار استفاده از یک متغیر استاتیک از نوع [`AtomicWaker`] است که توسط کریت "futures-util" ارائه شده است. مانند نوع `ArrayQueue`، این نوع نیز بر اساس دستورالعمل‌های اتمی است و می‌توان آن را به‌طور ایمن در یک استاتیک ذخیره کرد و همزمان اصلاح کرد.

[`AtomicWaker`]: https://docs.rs/futures-util/0.3.4/futures_util/task/struct.AtomicWaker.html

بیایید از نوع [`AtomicWaker`] برای تعریف "WAKER" استاتیک استفاده کنیم:

```rust
// in src/task/keyboard.rs

use futures_util::task::AtomicWaker;

static WAKER: AtomicWaker = AtomicWaker::new();
```

ایده این است که پیاده‌سازی `poll_next` بیدار کننده فعلی را در این استاتیک ذخیره می‌کند و تابع `add_scancode` وقتی یک اسکن کد جدید به صف اضافه می‌شود، تابع `wake` را روی آن فراخوانی می‌کند.

##### ذخیره یک Waker

قراردادی که توسط `poll`/`poll_next` تعریف شده است، مستلزم آن است که این وظیفه زمانی که `Poll::Pending` را برمی‌گرداند، یک بیدار باش (wakeup) برای `Waker` عبور داده شده ثبت کند. بیایید پیاده‌سازی `poll_next` را برای برآورده کردن این نیاز اصلاح کنیم:

```rust
// in src/task/keyboard.rs

impl Stream for ScancodeStream {
    type Item = u8;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Option<u8>> {
        let queue = SCANCODE_QUEUE
            .try_get()
            .expect("scancode queue not initialized");

        // fast path
        if let Ok(scancode) = queue.pop() {
            return Poll::Ready(Some(scancode));
        }

        WAKER.register(&cx.waker());
        match queue.pop() {
            Ok(scancode) => {
                WAKER.take();
                Poll::Ready(Some(scancode))
            }
            Err(crossbeam_queue::PopError) => Poll::Pending,
        }
    }
}
```

مانند قبل، ابتدا از تابع [`OnceCell::try_get`] برای دریافت مرجع به صف اسکن کد مقداردهی اولیه شده استفاده می‌کنیم. سپس به صورت خوش‌بینانه سعی می‌کنیم از صف `pop` کنیم و وقتی موفق شد `Poll::Ready` را برگردانیم. به این ترتیب، می‌توانیم از سربار عملکرد ثبت بیدار کننده در زمانی که صف خالی نیست، جلوگیری کنیم.

اگر اولین فراخوانی به `queue.pop()` موفقیت آمیز نباشد، صف احتمالا خالی است. فقط احتمالا زیرا کنترل‌کننده وقفه ممکن است بلافاصله پس از بررسی، صف را به صورت ناهمزمان پر کرده باشد. از آن‌جایی که این شرایط مسابقه می‌تواند دوباره برای بررسی بعدی رخ دهد، باید `Waker` را در استاتیک `WAKER` قبل از بررسی دوم ثبت کنیم. به این ترتیب، ممکن است قبل از این‌که `Poll::Pending` را برگردانیم، یک بیدار باش اتفاق بیفتد، اما تضمین می‌شود که برای هر اسکن کدی که پس از بررسی پوش می‌شود، یک بیدار باش دریافت می‌کنیم.

پس از ثبت `Waker` موجود در [`Context`] از طریق تابع [`AtomicWaker::register`]، برای بار دوم سعی می‌کنیم از صف پاپ کنیم. اگر اکنون موفق شد، `Poll::Ready` را برمی‌گردانیم. همچنین بیدار کننده ثبت شده را دوباره با استفاده از [`AtomicWaker::take`] حذف می‌کنیم، زیرا دیگر به اعلان بیدار کننده نیازی نیست. در صورتی که `queue.pop()` برای بار دوم ناموفق باشد، `Poll::Pending` را مانند قبل برمی‌گردانیم، اما این بار با یک بیدار باشِ ثبت‌شده.

[`AtomicWaker::register`]: https://docs.rs/futures-util/0.3.4/futures_util/task/struct.AtomicWaker.html#method.register
[`AtomicWaker::take`]: https://docs.rs/futures/0.3.4/futures/task/struct.AtomicWaker.html#method.take

توجه داشته باشید که دو راه وجود دارد که می‌تواند برای وظیفه‌ای که `Poll::Pending` (هنوز) برگردانده نشده، بیدار باش رخ دهد. یکی از راه‌ها شرایط مسابقه ذکر شده است زمانی که بیدار باش بلافاصله قبل از بازگشت `Poll::Pending` اتفاق می‌افتد. راه دیگر زمانی است که پس از ثبت بیدار کننده، صف دیگر خالی نباشد تا `Poll::Ready` برگردانده شود. از آن‌جایی که این بیدار باش‌های ساختگی قابل پیشگیری نیستند، اجرا کننده باید بتواند به درستی آن‌ها را مدیریت کند.

##### بیدار کردن Waker ذخیره شده

برای بیدار کردن `Waker` ذخیره شده، یک فراخوانی به `WAKER.wake()` در تابع `add_scancode` اضافه می‌کنیم:

```rust
// in src/task/keyboard.rs

pub(crate) fn add_scancode(scancode: u8) {
    if let Ok(queue) = SCANCODE_QUEUE.try_get() {
        if let Err(_) = queue.push(scancode) {
            println!("WARNING: scancode queue full; dropping keyboard input");
        } else {
            WAKER.wake(); // new
        }
    } else {
        println!("WARNING: scancode queue uninitialized");
    }
}
```

تنها تغییری که انجام دادیم اضافه کردن یک فراخوانی به `WAKER.wake()` در صورت موفقیت در پوش کردن به صف اسکن کد است. اگر یک بیدار کننده در استاتیک `WAKER` ثبت شده باشد، این متد، متدی با همین نام یعنی [`wake`] را روی آن فراخوانی می‌کند که به اجرا کننده اطلاع می‌دهد. در غیر این صورت، عملیات یک no-op است، یعنی هیچ اتفاقی نمی‌افتد.

[`wake`]: https://doc.rust-lang.org/stable/core/task/struct.Waker.html#method.wake

مهم است که ما `wake` را فقط پس از پوش کردن به صف فراخوانی کنیم زیرا در غیر این صورت ممکن است وقتی صف هنوز خالی است، وظیفه خیلی زود بیدار شود. به عنوان مثال، این اتفاق می‌تواند هنگام استفاده از یک اجرا کننده چند نخی که وظیفه بیدار شده را همزمان روی یک هسته CPU متفاوت شروع می‌کند، اتفاق بیفتد. در حالی که ما هنوز از نخ‌ها پشتیبانی نمی‌کنیم، اما به زودی آن را اضافه خواهیم کرد و نمی‌خواهیم چیزی در آن زمان خراب شود.

#### وظیفه صفحه‌کلید

اکنون که صفت `Stream` را برای `ScancodeStream` پیاده‌سازی کردیم، می‌توانیم از آن برای ایجاد یک وظیفه صفحه‌کلید ناهمزمان استفاده کنیم:

```rust
// in src/task/keyboard.rs

use futures_util::stream::StreamExt;
use pc_keyboard::{layouts, DecodedKey, HandleControl, Keyboard, ScancodeSet1};
use crate::print;

pub async fn print_keypresses() {
    let mut scancodes = ScancodeStream::new();
    let mut keyboard = Keyboard::new(layouts::Us104Key, ScancodeSet1,
        HandleControl::Ignore);

    while let Some(scancode) = scancodes.next().await {
        if let Ok(Some(key_event)) = keyboard.add_byte(scancode) {
            if let Some(key) = keyboard.process_keyevent(key_event) {
                match key {
                    DecodedKey::Unicode(character) => print!("{}", character),
                    DecodedKey::RawKey(key) => print!("{:?}", key),
                }
            }
        }
    }
}
```

کد بسیار شبیه به نسخه قبلی خودش است (قبل از تغییراتش درون این پست) که در [keyboard interrupt handler] داشتیم. تنها تفاوت این است که، به جای خواندن اسکن کد از یک پورت I/O، آن را از `ScancodeStream` می‌گیریم. برای این کار، ابتدا یک جریان `Scancode` جدید ایجاد می‌کنیم و سپس به طور مکرر از متد [`next`] ارائه شده توسط صفت [`StreamExt`] استفاده می‌کنیم تا یک `Future` به دست آوریم که به عنصر بعدی در جریان را حل می‌کند. با استفاده از عملگر `wait` روی آن، به طور ناهمزمان منتظر نتیجه فیوچر هستیم.

[keyboard interrupt handler]: @/edition-2/posts/07-hardware-interrupts/index.md#interpreting-the-scancodes
[`next`]: https://docs.rs/futures-util/0.3.4/futures_util/stream/trait.StreamExt.html#method.next
[`StreamExt`]: https://docs.rs/futures-util/0.3.4/futures_util/stream/trait.StreamExt.html

ما از `while let` برای ایجاد حلقه استفاده می‌کنیم تا زمانی که جریان مقدار `None` را برگرداند تا پایان آن را نشان دهد. از آن‌جایی که متد `poll_next` ما هرگز `None` را بر نمی‌گرداند، این در واقع یک حلقه بی‌پایان است، بنابراین وظیفه `print_keypresses` هرگز تمام نمی‌شود.

بیایید وظیفه `print_keypresses` را به اجرا کننده خود در `main.rs` اضافه کنیم تا دوباره ورودی صفحه‌کلیدی که به درستی کار می‌کند را داشته باشیم:

```rust
// in src/main.rs

use blog_os::task::keyboard; // new

fn kernel_main(boot_info: &'static BootInfo) -> ! {

    // […] initialization routines, including init_heap, test_main

    let mut executor = SimpleExecutor::new();
    executor.spawn(Task::new(example_task()));
    executor.spawn(Task::new(keyboard::print_keypresses())); // new
    executor.run();

    // […] "it did not crash" message, hlt_loop
}
```

الان وقتی `cargo run` را اجرا می‌کنیم، می‌بینیم که ورودی صفحه‌کلید دوباره کار می‌کند:

![QEMU printing ".....H...e...l...l..o..... ...W..o..r....l...d...!"](qemu-keyboard-output.gif)

اگر به استفاده از CPU رایانه خود توجه داشته باشید، خواهید دید که فرآیند QEMU اکنون به طور مداوم CPU را مشغول نگه می‌دارد. دلیلش این است که `SimpleExecutor` وظایف را بارها و بارها در یک حلقه نظرسنجی می‌کند. بنابراین حتی اگر هیچ کلیدی را روی صفحه‌کلید فشار ندهیم، اجرا کننده بارها و بارها `poll` را در وظیفه `print_keypresses` فراخوانی می‌کند، با وجود این‌که وظیفه هیچ پیشرفتی ندارد و هر بار `Poll::Pending` را برمی‌گرداند.

### اجرا کننده با پشتیبانی از Waker

برای رفع مشکل عملکرد (performance)، باید یک اجرا کننده ایجاد کنیم که به درستی از اعلان‌های `Waker` استفاده کند. به این ترتیب، وقتی وقفه بعدی صفحه‌کلید رخ می‌دهد، به اجرا کننده اطلاع داده می‌شود، بنابراین نیازی نیست بارها و بارها وظیفه `print_keypresses` را نظرسنجی کند.

#### شناسه وظیفه

اولین قدم در ایجاد یک اجرا کننده با پشتیبانی مناسب از اعلان‌های بیدار کننده این است که به هر وظیفه یک شناسه منحصر به فرد بدهید. این مورد نیاز است زیرا ما به راهی نیاز داریم تا مشخص کنیم کدام وظیفه باید بیدار شود. با ایجاد یک نوع بسته‌بندی `TaskId` جدید شروع می‌کنیم:

```rust
// in src/task/mod.rs

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct TaskId(u64);
```

ساختمان‌ `TaskId` یک نوع بسته‌بندی ساده در اطراف `u64` است. ما تعدادی صفت را برای آن استخراج می‌کنیم تا آن را قابل چاپ، کپی، قابل مقایسه و قابل مرتب‌سازی کنیم. مورد دوم مهم است زیرا می‌خواهیم از `TaskId` به عنوان نوع کلید یک [`BTreeMap`] در یک لحظه استفاده کنیم.

[`BTreeMap`]: https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html

برای ایجاد یک شناسه منحصر به فرد جدید، یک تابع `TaskId::new` ایجاد می‌کنیم:

```rust
use core::sync::atomic::{AtomicU64, Ordering};

impl TaskId {
    fn new() -> Self {
        static NEXT_ID: AtomicU64 = AtomicU64::new(0);
        TaskId(NEXT_ID.fetch_add(1, Ordering::Relaxed))
    }
}
```

این تابع از یک متغیر `NEXT_ID` استاتیک از نوع [`AtomicU64`] استفاده می‌کند تا اطمینان حاصل شود که هر شناسه فقط یک بار اختصاص داده شده است. متد [`fetch_add`] به صورت اتمی مقدار را افزایش می‌دهد و مقدار قبلی را در یک عملیات اتمی برمی‌گرداند. این بدان معناست که حتی زمانی که متد `TaskId::new` به صورت موازی فراخوانی می‌شود، هر ID دقیقاً یک بار برگردانده می‌شود. پارامتر [`Ordering`] تعیین می‌کند که آیا کامپایلر مجاز است عملیات `fetch_add` را در جریان دستورالعمل‌ها دوباره ترتیب دهد یا نه. از آن‌جایی که ما فقط نیاز داریم که شناسه منحصر به فرد باشد، در این مورد، مقدار `Relaxed` برای `Ordering` با ضعیف‌ترین شرایط کافی است.

[`AtomicU64`]: https://doc.rust-lang.org/core/sync/atomic/struct.AtomicU64.html
[`fetch_add`]: https://doc.rust-lang.org/core/sync/atomic/struct.AtomicU64.html#method.fetch_add
[`Ordering`]: https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html

اکنون می‌توانیم نوع `Task` خود را با یک فیلد `id` اضافی گسترش دهیم:

```rust
// in src/task/mod.rs

pub struct Task {
    id: TaskId, // new
    future: Pin<Box<dyn Future<Output = ()>>>,
}

impl Task {
    pub fn new(future: impl Future<Output = ()> + 'static) -> Task {
        Task {
            id: TaskId::new(), // new
            future: Box::pin(future),
        }
    }
}
```

فیلد `id` جدید امکان نام‌گذاری منحصربه‌فرد یک وظیفه را که برای بیدار کردن یک کار خاص لازم است، می‌سازد.

#### نوع `Executor`

نوع جدید `Executor` را در ماژول `task::executor` ایجاد می‌کنیم:

```rust
// in src/task/mod.rs

pub mod executor;
```

```rust
// in src/task/executor.rs

use super::{Task, TaskId};
use alloc::{collections::BTreeMap, sync::Arc};
use core::task::Waker;
use crossbeam_queue::ArrayQueue;

pub struct Executor {
    tasks: BTreeMap<TaskId, Task>,
    task_queue: Arc<ArrayQueue<TaskId>>,
    waker_cache: BTreeMap<TaskId, Waker>,
}

impl Executor {
    pub fn new() -> Self {
        Executor {
            tasks: BTreeMap::new(),
            task_queue: Arc::new(ArrayQueue::new(100)),
            waker_cache: BTreeMap::new(),
        }
    }
}
```

به‌جای ذخیره وظایف در [`VecDeque`] مانند آن‌چه برای `SimpleExecutor` انجام دادیم، از یک `task_queue` از شناسه‌های وظیفه و یک [`BTreeMap`] به نام `tasks` استفاده می‌کنیم که حاوی نمونه‌های `Task` واقعی است. نگاشت توسط `TaskId` ایندکس می‌شود تا امکان ادامه کارآمد یک وظیفه خاص را فراهم کند.

فیلد `task_queue` یک [`ArrayQueue`] از شناسه‌های وظیفه است که در نوع [`Arc`] بسته‌بندی شده است که _reference counting_ را پیاده‌سازی می‌کند. شمارش ارجاع، امکان به اشتراک گذاشتن مالکیتِ مقدار بین چندین مالک را فراهم می‌کند. این با تخصیص مقدار روی هیپ و شمارش تعداد مراجع فعال به آن، کار می‌کند. هنگامی که تعداد مراجع فعال به صفر رسید، مقدار دیگر مورد نیاز نیست و می‌توان آن را جابجا کرد.

ما از این نوع `Arc<ArrayQueue>` برای `task_queue` استفاده می‌کنیم زیرا بین اجرا کننده و بیدار کننده‌ها به اشتراک گذاشته می‌شود. ایده این است که بیدار کننده‌ها شناسه وظیفه بیدار شده را به صف پوش کنند. اجرا کننده در انتهای دریافت صف می‌نشیند، وظایف بیدار شده را با شناسه خود از نگاشت `tasks` بازیابی می‌کند و سپس آن‌ها را اجرا می‌کند. دلیل استفاده از یک صف با اندازه ثابت به جای یک صف نامحدود مانند [`SegQueue`] این است که کنترل کننده‌های وقفه که نباید تخصیص دهند، به این صف پوش می‌کنند.

علاوه بر نگاشت `task_queue` و `tasks`، نوع `Executor` یک فیلد `waker_cache` دارد که یک نگاشت نیز هست. این نگاشت [`Waker`] یک وظیفه را پس از ایجاد آن، در حافظه پنهان (cache) ذخیره می‌کند. این کار دو دلیل دارد: اول این‌که با استفاده مجدد از یک بیدار کننده برای چندین بیدار باش از یک وظیفه، به جای ایجاد یک بیدار کننده جدید در هر بار، عملکرد را بهبود می‌بخشد. دوم، تضمین می‌کند که بیدار کننده‌های شمارش‌شده مرجع در داخل کنترل کننده‌های وقفه آزادسازی (deallocated) نشود، زیرا می‌تواند منجر به بن‌بست شود (جزئیات بیشتری در این مورد در زیر وجود دارد).

[`Arc`]: https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html
[`SegQueue`]: https://docs.rs/crossbeam-queue/0.2.1/crossbeam_queue/struct.SegQueue.html

برای ایجاد یک `Executor`، یک تابع `new` ساده فراهم می‌کنیم. ما ظرفیت 100 را برای `task_queue` انتخاب می‌کنیم که برای فیوچر قابل پیش‌بینی، باید بیش از اندازه کافی باشد. در صورتی که سیستم ما در یک مقطع زمانی بیش از 100 وظیفه همزمان داشته باشد، به راحتی می‌توانیم این اندازه را افزایش دهیم.

#### وظایف Spawning

در مورد `SimpleExecutor`، ما یک متد `spawn` را در نوع `Executor` ارائه می کنیم که یک وظیفه معین را به نگاشت `tasks` اضافه می‌کند و بلافاصله با پوش کردن شناسه آن به `task_queue` آن را بیدار می‌کند:

```rust
// in src/task/executor.rs

impl Executor {
    pub fn spawn(&mut self, task: Task) {
        let task_id = task.id;
        if self.tasks.insert(task.id, task).is_some() {
            panic!("task with same ID already in tasks");
        }
        self.task_queue.push(task_id).expect("queue full");
    }
}
```

اگر قبلاً وظیفه‌ای با همان شناسه در نگاشت وجود داشته باشد، متد [`BTreeMap::insert`] آن را برمی‌گرداند. این حالت هرگز نباید اتفاق بیفتد زیرا هر وظیفه یک شناسه منحصر به فرد دارد، بنابراین ما در این مورد پنیک داریم زیرا نشان‌دهنده یک اشکال در کد ما است. به طور مشابه، وقتی `task_queue` پر است، پنیک می‌کنیم زیرا اگر اندازه صف به اندازه کافی بزرگ انتخاب کنیم، هرگز نباید این اتفاق بیفتد.

#### اجرای وظیفه‌ها

برای اجرای همه وظایف در `task_queue`، یک متد `run_ready_tasks` خصوصی ایجاد می‌کنیم:

```rust
// in src/task/executor.rs

use core::task::{Context, Poll};

impl Executor {
    fn run_ready_tasks(&mut self) {
        // destructure `self` to avoid borrow checker errors
        let Self {
            tasks,
            task_queue,
            waker_cache,
        } = self;

        while let Ok(task_id) = task_queue.pop() {
            let task = match tasks.get_mut(&task_id) {
                Some(task) => task,
                None => continue, // task no longer exists
            };
            let waker = waker_cache
                .entry(task_id)
                .or_insert_with(|| TaskWaker::new(task_id, task_queue.clone()));
            let mut context = Context::from_waker(waker);
            match task.poll(&mut context) {
                Poll::Ready(()) => {
                    // task done -> remove it and its cached waker
                    tasks.remove(&task_id);
                    waker_cache.remove(&task_id);
                }
                Poll::Pending => {}
            }
        }
    }
}
```

ایده اصلی این تابع شبیه به `SimpleExecutor` است: همه وظایف درون `task_queue` را در یک حلقه پیمایش کنید، برای هر کار یک بیدار کننده ایجاد کنید و سپس آن را نظرسنجی کنید. با این حال، به‌جای افزودن وظایف معلق به انتهای `task_queue`، به پیاده‌سازی `TaskWaker` خود اجازه می‌دهیم تا وظایف بیدار شده را به صف اضافه کند. اجرای این نوع بیدار کننده در بزودی نشان داده خواهد شد.

بیایید به برخی از جزئیات پیاده‌سازی این متد `run_ready_tasks` نگاه کنیم:

- ما از [_destructuring_] برای تقسیم `self` به سه فیلد آن استفاده می‌کنیم تا از برخی خطاهای borrow checker جلوگیری کنیم. یعنی، پیاده‌سازی ما باید از داخل یک closure به `self.task_queue` دسترسی داشته باشد، که در حال حاضر سعی می‌کند `self` را به‌طور کامل قرض بگیرد. این یک مشکل اساسی بررسی کننده قرض است که با [پیاده‌سازی][RFC 2229 impl] [RFC 2229] حل خواهد شد.

- برای هر شناسه وظیفه پاپ شده، یک مرجع قابل تغییر به وظیفه مربوطه را از نگاشت `tasks` بازیابی می‌کنیم. از آن‌جایی که پیاده‌سازی `ScancodeStream` قبل از بررسی این‌که آیا یک وظیفه باید به حالت خواب برده شود یا خیر، بیدار کننده‌ها را ثبت می‌کند، ممکن است بیدار باش برای کاری که دیگر وجود ندارد رخ دهد. در این حالت به سادگی بیدار باش را نادیده می‌گیریم و با ID بعدی از صف ادامه می‌دهیم.

- برای جلوگیری از سربار عملکرد ایجاد یک بیدار کننده در هر نظرسنجی، از نگاشت `waker_cache` برای ذخیره بیدار کننده برای هر وظیفه پس از ایجاد آن استفاده می‌کنیم. برای این کار، از متد [`BTreeMap::entry`] در ترکیب با [`Entry::or_insert_with`] استفاده می‌کنیم تا یک بیدار کننده جدید ایجاد کنیم، اگر هنوز وجود نداشته باشد و سپس یک مرجع قابل تغییر به آن دریافت کنیم. برای ایجاد یک بیدار کننده جدید، `task_queue` را شبیه‌سازی می‌کنیم و آن را همراه با شناسه وظیفه به تابع `TaskWaker::new` می‌فرستیم (پیاده‌سازی نشان داده شده در زیر). از آن‌جایی که `task_queue` در `Arc` بسته‌بندی شده است، `clone` تنها تعداد شمارش مرجع برای مقدار را افزایش می‌دهد، اما همچنان به همان صف تخصیص داده شده اشاره می‌کند. توجه داشته باشید که استفاده مجدد از بیدار کننده‌هایی مانند این برای همه پیاده‌سازی‌های بیدار کننده امکان‌پذیر نیست، اما نوع `TaskWaker` این اجازه را می‌دهد.

[_destructuring_]: https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values
[RFC 2229]: https://github.com/rust-lang/rfcs/pull/2229
[RFC 2229 impl]: https://github.com/rust-lang/rust/issues/53488

[`BTreeMap::entry`]: https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html#method.entry
[`Entry::or_insert_with`]: https://doc.rust-lang.org/alloc/collections/btree_map/enum.Entry.html#method.or_insert_with

وقتی یک وظیفه `Poll::Ready` را برگرداند به اتمام می‌رسد. در این صورت، با استفاده از متد [`BTreeMap::remove`] آن را از نگاشت `tasks` حذف می‌کنیم. در صورت وجود، بیدار کننده ذخیره شده، آن را نیز حذف می‌کنیم.

[`BTreeMap::remove`]: https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html#method.remove

#### طراحی بیدار کننده

وظیفه بیدار کننده این است که شناسه وظیفه بیدار شده را به `task_queue` اجرا کننده پوش کند. ما این را با اجرای یک ساختمان‌ `TaskWaker` جدید، پیاده‌سازی می‌کنیم که شناسه وظیفه و یک مرجع به `task_queue` را ذخیره می‌کند:

```rust
// in src/task/executor.rs

struct TaskWaker {
    task_id: TaskId,
    task_queue: Arc<ArrayQueue<TaskId>>,
}
```

از آن‌جایی که مالکیت `task_queue` بین اجرا کننده و بیدار کننده‌ها به اشتراک گذاشته شده است، ما از نوع بسته‌بندی [`Arc`] برای پیاده‌سازی مالکیت مشترک شمارش شده مرجع استفاده می‌کنیم.

[`Arc`]: https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html

 پیاده‌سازی عملیات بیداری بسیار ساده است:

```rust
// in src/task/executor.rs

impl TaskWaker {
    fn wake_task(&self) {
        self.task_queue.push(self.task_id).expect("task_queue full");
    }
}
```

ما `task_id` را به `task_queue` ارجاع شده فشار می‌کنیم. از آن‌جایی که تغییرات نوع [`ArrayQueue`] فقط به یک مرجع مشترک نیاز دارند، می‌توانیم این متد را به جای `&mut self` روی `&self` پیاده‌سازی کنیم.

##### صفت `Wake`

برای استفاده از نوع `TaskWaker` برای نظرسنجی فیوچر، ابتدا باید آن را به یک نمونه [`Waker`] تبدیل کنیم. این مورد نیاز است زیرا متد [`Future::poll`] یک نمونه [`Context`] را به عنوان آرگومان می‌گیرد، که فقط می‌تواند از نوع `Waker` ساخته شود. در حالی که می‌توانیم این کار را با فراهم کردن یک پیاده‌سازی از نوع [`RawWaker`] انجام دهیم، ساده‌تر و ایمن‌تر است که به جای آن صفت [`Wake`][wake-trait] مبتنی بر `Arc` را پیاده‌سازی کنیم و سپس از پیاده‌سازی‌های [`From`] ارائه شده توسط کتابخانه استاندارد برای ساخت `Waker` استفاده کنیم.

پیاده‌سازی صفت به صورت زیر است:

[wake-trait]: https://doc.rust-lang.org/nightly/alloc/task/trait.Wake.html

```rust
// in src/task/executor.rs

use alloc::task::Wake;

impl Wake for TaskWaker {
    fn wake(self: Arc<Self>) {
        self.wake_task();
    }

    fn wake_by_ref(self: &Arc<Self>) {
        self.wake_task();
    }
}
```

از آن‌جایی که بیدار کننده‌ها معمولاً بین اجرا کننده و وظایف ناهمزمان به اشتراک گذاشته می‌شوند، متدهای صفت مستلزم آن هستند که نمونه `Self` در نوع [`Arc`] بسته‌بندی شود، که مالکیت شمارش مرجع را پیاده‌سازی می‌کند. این بدان معنی است که باید `TaskWaker` خود را به یک `Arc` منتقل کنیم تا آن‌ها را فراخوانی کنیم.

تفاوت بین متدهای `wake` و `wake_by_ref` در این است که دومی فقط به ارجاع به `Arc` نیاز دارد، در حالی که اولی مالکیت `Arc` را در اختیار می‌گیرد و بنابراین اغلب نیاز به افزایش تعداد مراجع دارد. همه انواع از بیدار شدن با مرجع پشتیبانی نمی‌کنند، بنابراین پیاده‌سازی متد `wake_by_ref` اختیاری است، اما می‌تواند به عملکرد بهتر منجر شود زیرا از تغییرات غیر ضروری تعداد مراجع جلوگیری می‌کند. در مورد ما، ما به سادگی می‌توانیم هر دو متد صفت را به تابع `wake_task` خود ارسال کنیم، که فقط به یک مرجع مشترک `&self` نیاز دارد.

##### ساختن بیدار کننده‌ها

از آن‌جایی که نوع `Waker` از تبدیل‌های [`From`] برای همه مقادیر `Arc` که صفت `Wake` را پیاده‌سازی می‌کنند، پشتیبانی می‌کند، اکنون می‌توانیم تابع `TaskWaker::new` را که توسط `Executor::run_ready_tasks` مورد نیاز است، پیاده‌سازی کنیم:

[`From`]: https://doc.rust-lang.org/nightly/core/convert/trait.From.html

```rust
// in src/task/executor.rs

impl TaskWaker {
    fn new(task_id: TaskId, task_queue: Arc<ArrayQueue<TaskId>>) -> Waker {
        Waker::from(Arc::new(TaskWaker {
            task_id,
            task_queue,
        }))
    }
}
```

ما `TaskWaker` را با استفاده از `task_id` و `task_queue` عبور داده شده به تابع ایجاد می‌کنیم. سپس `TaskWaker` را در یک `Arc` بسته‌بندی می‌کنیم و از پیاده‌سازی `Waker::from` برای تبدیل آن به [`Waker`] استفاده می‌کنیم. این متد `from` به ساخت یک [`RawWakerVTable`] و یک نمونه [`RawWaker`] برای نوع `TaskWaker` رسیدگی می‌کند. در صورتی که علاقه‌مند به نحوه عملکرد آن با جزئیات هستید، [پیاده‌سازی در کریت `alloc`][waker-from-impl] را بررسی کنید.

[waker-from-impl]: https://github.com/rust-lang/rust/blob/cdb50c6f2507319f29104a25765bfb79ad53395c/src/liballoc/task.rs#L58-L87

#### یک متد `run`

با پیاده‌سازی بیدار کننده، در نهایت می‌توانیم یک متد `run` برای اجرا کننده خود بسازیم:

```rust
// in src/task/executor.rs

impl Executor {
    pub fn run(&mut self) -> ! {
        loop {
            self.run_ready_tasks();
        }
    }
}
```

این متد فقط تابع `run_ready_tasks` را در یک حلقه فراخوانی می‌کند. در حالی که از نظر تئوری می‌توانیم زمانی که نگاشت `tasks` خالی می‌شود، از تابع برگردیم، این هرگز اتفاق نمی‌افتد زیرا `keyboard_task` هرگز تمام نمی‌شود، بنابراین یک `loop` ساده کافی است. از آن‌جایی که تابع هرگز برنمی‌گردد، از نوع بازگشت `!` برای علامت‌گذاری تابع به عنوان [واگرا] به کامپایلر استفاده می‌کنیم.

[واگرا]: https://doc.rust-lang.org/stable/rust-by-example/fn/diverging.html

اکنون می‌توانیم `kernel_main` را تغییر دهیم تا از `Executor` جدید خود به‌جای `SimpleExecutor` استفاده کنیم:

```rust
// in src/main.rs

use blog_os::task::executor::Executor; // new

fn kernel_main(boot_info: &'static BootInfo) -> ! {
    // […] initialization routines, including init_heap, test_main

    let mut executor = Executor::new(); // new
    executor.spawn(Task::new(example_task()));
    executor.spawn(Task::new(keyboard::print_keypresses()));
    executor.run();
}
```

فقط باید وارد کردن و نام نوع را تغییر دهیم. از آن‌جایی که تابع `run` به عنوان واگرا علامت‌گذاری شده است، کامپایلر می‌داند که هرگز برنمی‌گردد، بنابراین دیگر نیازی به فراخوانی `hlt_loop` در انتهای تابع `kernel_main` نداریم.

وقتی اکنون هسته خود را با استفاده از `cargo run` اجرا می‌کنیم، می‌بینیم که ورودی صفحه‌کلید همچنان کار می‌کند:

![QEMU printing ".....H...e...l...l..o..... ...a..g..a....i...n...!"](qemu-keyboard-output-again.gif)

با این حال، استفاده QEMU از CPU بهبود نیافته است. زیرا هنوز CPU را برای تمام مدت مشغول نگه می‌داریم. ما دیگر از وظایف نظرسنجی نمی‌کنیم تا زمانی که دوباره بیدار شوند، اما همچنان `task_queue` را در یک حلقه‌ی مشغول بررسی می‌کنیم. برای رفع این مشکل، اگر وظیفه دیگری وجود ندارد، باید CPU را در حالت Sleep قرار دهیم.

#### در صورت idle بخواب

ایده اصلی، اجرا کردن [`دستورالعمل hlt`] در زمانی است که `task_queue` خالی باشد. این دستورالعمل، CPU را تا رسیدن وقفه بعدی در حالت Sleep قرار می‌دهد. این واقعیت که CPU بلافاصله مجدداً در وقفه‌ها فعال می‌شود، تضمین می‌کند که ما همچنان می‌توانیم مستقیماً زمانی که یک کنترل‌کننده وقفه به `task_queue` پوش می‌کند، واکنش نشان دهیم.

[دستورالعمل hlt]: https://en.wikipedia.org/wiki/HLT_(x86_instruction)

برای پیاده‌سازی این، یک متد جدید `sleep_if_idle` در اجرا کننده ایجاد می‌کنیم و آن را از متد `run` فراخوانی می‌کنیم:

```rust
// in src/task/executor.rs

impl Executor {
    pub fn run(&mut self) -> ! {
        loop {
            self.run_ready_tasks();
            self.sleep_if_idle();   // new
        }
    }

    fn sleep_if_idle(&self) {
        if self.task_queue.is_empty() {
            x86_64::instructions::hlt();
        }
    }
}
```

از آن‌جایی که ما `sleep_if_idle` را مستقیماً بعد از `run_ready_tasks` فراخوانی می‌کنیم، که تا زمانی که `task_queue` خالی شود یک حلقه را اجرا می‌کند، بررسی مجدد صف ممکن است غیرضروری به نظر برسد. با این حال، ممکن است یک وقفه سخت‌افزاری مستقیماً پس از بازگشت `run_ready_tasks` رخ دهد، بنابراین ممکن است در زمان فراخوانی تابع `sleep_if_idle` یک وظیفه جدید در صف وجود داشته باشد. فقط در صورتی که صف همچنان خالی باشد، CPU را با اجرای دستورالعمل `hlt` از طریق تابع بسته‌بندی [`instructions::hlt`] ارائه شده توسط کریت [`x86_64`] به خواب می‌بریم.

[`instructions::hlt`]: https://docs.rs/x86_64/0.14.2/x86_64/instructions/fn.hlt.html
[`x86_64`]: https://docs.rs/x86_64/0.14.2/x86_64/index.html

متأسفانه، هنوز یک شرط مسابقه ظریف در این پیاده‌سازی وجود دارد. از آن‌جایی که وقفه‌ها ناهمزمان هستند و می‌توانند در هر زمانی اتفاق بیفتند، ممکن است یک وقفه درست بین بررسی `is_empty` و فراخوانی `hlt` اتفاق بیفتد:

```rust
if self.task_queue.is_empty() {
    /// <--- interrupt can happen here
    x86_64::instructions::hlt();
}
```

در صورتی که این وقفه به `task_queue` پوش کند، ما CPU را در حالت Sleep قرار می‌دهیم، هر چند که اکنون یک وظیفه آماده وجود دارد. در بدترین حالت، این می‌تواند مدیریت وقفه صفحه‌کلید را تا فشردن کلید بعدی یا وقفه بعدی تایمر به تاخیر بیاندازد. پس چگونه از آن جلوگیری کنیم؟

پاسخ این است که قبل از بررسی، وقفه‌های CPU را غیرفعال کنید و به همراه دستور `hlt` دوباره آن‌ها را به صورت اتمی فعال کنید. به این ترتیب، تمام وقفه‌هایی که در این بین اتفاق می‌افتند، پس از دستور `hlt` به تأخیر می‌افتند تا هیچ بیدار باشی از دست نرود. برای پیاده‌سازی این رویکرد، می‌توانیم از تابع [`interrupts::enable_and_hlt`][`enable_and_hlt`] استفاده کنیم که توسط کریت [`x86_64`] ارائه شده است.

[`enable_and_hlt`]: https://docs.rs/x86_64/0.14.2/x86_64/instructions/interrupts/fn.enable_and_hlt.html

پیاده‌سازی بروز شده تابع `sleep_if_idle` به شکل زیر است:

```rust
// in src/task/executor.rs

impl Executor {
    fn sleep_if_idle(&self) {
        use x86_64::instructions::interrupts::{self, enable_and_hlt};

        interrupts::disable();
        if self.task_queue.is_empty() {
            enable_and_hlt();
        } else {
            interrupts::enable();
        }
    }
}
```

برای اجتناب از شرایط مسابقه، قبل از بررسی خالی بودن `task_queue`، وقفه‌ها را غیرفعال می‌کنیم. اگر اینطور است، از تابع [`enable_and_hlt`] برای فعال کردن وقفه‌ها استفاده می‌کنیم و CPU را به عنوان یک عملیات اتمی در حالت Sleep قرار می‌دهیم. در صورتی که صف دیگر خالی نباشد، به این معنی است که یک وقفه پس از بازگشت `run_ready_tasks` یک وظیفه را بیدار کرده است. در آن صورت، وقفه‌ها را دوباره فعال می‌کنیم و مستقیماً بدون اجرای `hlt` اجرا را ادامه می‌دهیم.

اکنون اجرا کننده به درستی CPU را هنگامی که کاری برای انجام دادن وجود ندارد به حالت Sleep می‌برد. هنگامی که دوباره هسته را با استفاده از `cargo run` اجرا می‌کنیم، می‌بینیم که فرآیند QEMU مصرف بسیار کمتری از CPU دارد.

#### افزونه‌های احتمالی

اجرا کننده ما اکنون قادر است وظایف را به روشی کارآمد اجرا کند. از اعلان‌های بیدار کننده برای جلوگیری از انجام وظایف معلق نظرسنجی استفاده می‌کند و CPU را در زمانی که در حال حاضر کاری برای انجام دادن وجود ندارد به حالت خواب می‌برد. با این حال، اجرا کننده ما هنوز کاملاً ابتدایی است و راه‌های ممکن زیادی برای گسترش عملکرد آن وجود دارد:

- **زمانبندی**: ما در حال حاضر از نوع [`VecDeque`] برای پیاده‌سازی استراتژی _first in first out_ (FIFO) برای `task_queue` خود استفاده می‌کنیم که اغلب به آن زمانبندی _round robin_ نیز می‌گویند. این استراتژی ممکن است برای همه حجم‌های کاری کارآمدترین نباشد. به عنوان مثال، ممکن است منطقی باشد که به وظایفی که تأخیر در آن‌ها حیاتی است یا وظایفی که I/O زیادی را انجام می‌دهند، اولویت بیشتری دهیم. برای اطلاعات بیشتر به [فصل زمان‌بندی] از کتاب [_سیستم‌های عامل: سه قطعه آسان_] یا [مقاله ویکی‌پدیا در مورد زمان‌بندی][scheduling-wiki] مراجعه کنید.

- **تولید مثل وظایف**: متد `Executor::spawn` در حال حاضر به مرجع `&mut self` نیاز دارد و بنابراین پس از شروع متد `run` دیگر در دسترس نیست. برای رفع این مشکل، می‌توانیم یک نوع `Spawner` اضافی ایجاد کنیم که نوعی صف را با اجرا کننده به اشتراک می‌گذارد و اجازه ایجاد کردن وظیفه از درون خود وظایف را می‌دهد. صف می‌تواند به‌عنوان مثال مستقیماً `task_queue` یا یک صف جداگانه باشد که اجرا کننده در حلقه اجرا آن را بررسی می‌کند.
- **استفاده از نخ‌ها**: ما هنوز از نخ‌ها پشتیبانی نمی‌کنیم، اما در پست بعدی اضافه خواهیم کرد. این امکان راه‌اندازی چندین نمونه از اجرا کننده در نخ‌های مختلف را فراهم می‌کند. مزیت این روش این است که تاخیر تحمیل شده توسط وظایف طولانی مدت را می‌توان کاهش داد زیرا سایر وظایف می‌توانند همزمان اجرا شوند. این رویکرد همچنین امکان استفاده از چندین هسته CPU را فراهم می‌کند.
- **تعادل بار**: هنگام اضافه کردن پشتیبانی نخ، نحوه توزیع وظایف بین اجرا کننده‌ها برای اطمینان از استفاده از تمام هسته‌های CPU مهم می‌شود. یک تکنیک رایج برای این [_سرقت کار_] است.

[فصل زمان‌بندی]: http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf
[_سیستم‌های عامل: سه قطعه آسان_]: http://pages.cs.wisc.edu/~remzi/OSTEP/
[scheduling-wiki]: https://en.wikipedia.org/wiki/Scheduling_(computing)
[_سرقت کار_]: https://en.wikipedia.org/wiki/Work_stealing

## خلاصه

ما این پست را با معرفی **چند وظیفه‌ای** و تمایز بین چند وظیفه‌ای _پیشگیرانه_، که به طور اجباری وظایف در حال اجرا را به طور منظم قطع می‌کند، و چندوظیفه‌ای _تعاونی_، که به وظایف اجازه می‌دهد تا زمانی که به طور داوطلبانه کنترل CPU را رها نکرده‌اند اجرا شوند، شروع کردیم.

سپس بررسی کردیم که چگونه پشتیبانی راست از **async/await** اجرای چند وظیفه‌ای تعاونی را در سطح زبان ارائه می‌دهد. راست پیاده‌سازی خود را بر پایه صفت `Future` مبتنی بر نظرسنجی استوار می‌کند، که وظایف ناهمزمان را انتزاع می‌کند. با استفاده از async/await، می‌توان با فیوچرها تقریباً مانند کدهای همزمان معمولی کار کرد. تفاوتش در این است که توابع ناهمزمان دوباره یک `Future` را برمی‌گرداند، که برای اجرای آن باید در نقطه‌ای به یک اجرا کننده اضافه شود.

در پشت صحنه، کامپایلر کد async/await را به  _حالت ماشین_ تبدیل می‌کند و هر عملیات `.await` مربوط به یک نقطه توقف احتمالی است. با استفاده از دانش خود در مورد برنامه، کامپایلر قادر است تنها حداقل حالت را برای هر نقطه توقف ذخیره کند و در نتیجه مصرف حافظه بسیار کمی در هر کار به همراه دارد. یک چالش این است که ماشین‌های حالت تولید شده ممکن است دارای ساختمان‌های _خود ارجاعی_ باشند، برای مثال زمانی که متغیرهای محلی تابع ناهمزمان به یکدیگر ارجاع می‌دهند. برای جلوگیری از باطل شدن اشاره‌گر، راست از نوع `Pin` استفاده می‌کند تا اطمینان حاصل کند که فیوچرها پس از اولین نظرسنجی دیگر نمی‌توانند در حافظه جابجا شوند.

برای **پیاده‌سازی**، ابتدا یک اجرا کننده بسیار ابتدایی ایجاد کردیم که همه وظایف ایجاد شده را در یک حلقه مشغول نظرسنجی می‌کند بدون اینکه اصلاً از نوع `Waker` استفاده شود. سپس با اجرای یک وظیفه صفحه‌کلید ناهمزمان، مزیت اعلان‌های بیدار کننده را نشان دادیم. این کار یک `SCANCODE_QUEUE` ثابت را با استفاده از نوع `ArrayQueue` بدون mutex ارائه شده توسط کریت `crossbeam` تعریف می‌کند. کنترل کننده وقفه صفحه‌کلید به جای مدیریت مستقیم کلیدها، اکنون همه اسکن کدهای دریافتی را در صف قرار می‌دهد و سپس `Waker` ثبت شده را بیدار می‌کند تا سیگنال ورودی جدید در دسترس باشد. در انتهای دریافت، ما یک نوع `ScancodeStream` ایجاد کردیم تا یک `Future` را به اسکن کد بعدی در صف ارائه کنیم. این امکان ایجاد یک وظیفه ناهمزمان `print_keypresses` را فراهم کرد که از async/await برای تفسیر و چاپ کدهای اسکن موجود در صف استفاده می‌کند.

برای استفاده از اعلان‌های بیدار کننده وظیفه صفحه‌کلید، یک نوع `Executor` جدید ایجاد کردیم که از `task_queue` اشتراک‌گذاری شده با `Arc` برای وظیفه‌های آماده استفاده می‌کند. ما یک نوع `TaskWaker` را پیاده‌سازی کردیم که شناسه وظایف بیدار شده را مستقیماً به این `task_queue` منتقل می‌کند، که سپس دوباره توسط اجرا کننده نظرسنجی می‌شود. برای صرفه‌جویی در مصرف انرژی در زمانی که هیچ وظیفه‌ای قابل اجرا نیست، با استفاده از دستورالعمل `hlt`، پشتیبانی از قرار دادن CPU در حالت Sleep را اضافه کردیم. در نهایت، برخی از برنامه‌های افزودنی بالقوه اجرا کننده خود را مورد بحث قرار دادیم، به عنوان مثال برای ارائه پشتیبانی چند هسته‌ای.

## بعدی چیست؟

با استفاده از async/await، ما اکنون از پشتیبانی اولیه برای چند وظیفه‌ای تعاونی در هسته خود داریم. در حالی که چند وظیفه‌ای تعاونی  بسیار کارآمد است، هنگامی که وظایف خاصی برای مدت طولانی اجرا می‌شوند، منجر به مشکلات تاخیر می‌شود و بنابراین از اجرای سایر وظایف جلوگیری می‌کند. به همین دلیل منطقی است که پشتیبانی از چند وظیفه‌ای پیشگیرانه را نیز به هسته خود اضافه کنیم.

در پست بعدی _نخ‌ها_ را به عنوان رایج‌ترین شکل چند وظیفه‌ای پیشگیرانه معرفی خواهیم کرد. علاوه بر حل مشکل وظایف طولانی مدت، نخ‌ها همچنین ما را برای استفاده از چندین هسته CPU و اجرای برنامه‌های نامعتبر کاربر در آینده آماده می‌کنند.
